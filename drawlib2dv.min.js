//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// For JSHint - I don't want to add strict to each function but I am wary
// of file scope in case it leaks and this is a library.
// Allow nonstandard for escape / unescape
/*jshint strict:false, nonstandard:true */

// All methods should be created as members of this.
// Global object to be used as a namespace.
var DRAWLIB = {};
DRAWLIB.p_IMGINFO = {};

/**
 * Create a Picture object
 * DRAWLIB.createPicture creates a picture object associated with a canvas
 * that owns a list of drawing items and supports panning, zooming and
 * rotation.
 *
 * @param canvas The canvas object on which to draw
 * @param background Background color - string '#RRGGBB'
 * @param canvasWidth Initial width in pixels of the canvas
 * @param canvasHeight Initial height in pixels of the canvas
 * @return Picture object
 */
DRAWLIB.createPicture = function(canvas, background) {
    var onePic = {'p_canvas':canvas};
    onePic.p_ctxt = onePic.p_canvas.getContext("2d");
    onePic.p_items = {};
    onePic.p_itemsById = {}; // indexed by db id as a string
    onePic.p_background = background;
    onePic.p_canvasWidth = canvas.width;
    onePic.p_canvasHeight = canvas.height;
    onePic.p_origCanvasWidth = canvas.width; // Original value
    onePic.p_origCanvasHeight = canvas.height; // Original value
    onePic.p_window = [0, 0, canvas.width, canvas.height];
    onePic.p_windowBoundary = undefined;
    onePic.p_minZ = 0;
    onePic.p_maxZ = 0;
    onePic.p_rotation = 0; // units of 90 degrees clockwise window under page
    onePic.p_redrawFunc = undefined; // No redraw callback initially
    onePic.setRedrawFunc = DRAWLIB.m_setRedrawFunc;
    onePic.resetCanvasDimensions = DRAWLIB.m_resetCanvasDimensions;
    onePic.getMinZ = DRAWLIB.m_getMinZ;
    onePic.getMaxZ = DRAWLIB.m_getMaxZ;
    onePic.setZ = DRAWLIB.m_setZPic;
    onePic.p_drawItemsByZ = DRAWLIB.p_drawItemsByZ;
    onePic.redrawAll = DRAWLIB.m_redrawAll;
    onePic.redrawAllToCanvas = DRAWLIB.m_redrawAllToCanvas;
    onePic.redrawAllToImageWindow = DRAWLIB.m_redrawAllToImageWindow;
    onePic.redrawSectionPage = DRAWLIB.m_redrawSectionPage;
    onePic.redrawSectionWindowLayer = DRAWLIB.m_redrawSectionWindowLayer;
    onePic.p_setClip = DRAWLIB.p_setClip;
    onePic.redrawFrame = DRAWLIB.m_redrawFrame;
    onePic.blank = DRAWLIB.m_blank;
    onePic.blankCanvasRect = DRAWLIB.m_blankCanvasRect;
    onePic.p_redrawOneFrame = DRAWLIB.p_redrawOneFrame;
    onePic.redrawLayer = DRAWLIB.m_redrawLayer;
    onePic.p_redrawSectionWindow= DRAWLIB.p_redrawSectionWindow;
    onePic.p_redrawSectionCanvas = DRAWLIB.p_redrawSectionCanvas;
    onePic.drawDragRect = DRAWLIB.m_drawDragRect; 
    onePic.drawDragEllipse = DRAWLIB.m_drawDragEllipse; 
    onePic.drawPageRect = DRAWLIB.m_drawPageRect;
    onePic.drawPageLine = DRAWLIB.m_drawPageLine;
    onePic.setWindow = DRAWLIB.m_setWindow;
    onePic.setWindowWithResize = DRAWLIB.m_setWindowWithResize;
    onePic.setWindowBoundary = DRAWLIB.m_setWindowBoundary;
    onePic.getWindowBoundary = DRAWLIB.m_getWindowBoundary;
    onePic.getRotation = DRAWLIB.m_getRotation;
    onePic.setRotation = DRAWLIB.m_setRotation;
    onePic.zoomIn = DRAWLIB.m_zoomIn;
    onePic.zoomOut = DRAWLIB.m_zoomOut;
    onePic.panPic = DRAWLIB.m_panPic;
    onePic.panUp = DRAWLIB.m_panUp;
    onePic.panDown = DRAWLIB.m_panDown;
    onePic.panLeft = DRAWLIB.m_panLeft;
    onePic.panRight = DRAWLIB.m_panRight;
    onePic.panToCentre = DRAWLIB.m_panToCentre;
    onePic.pageToCanvasCoords = DRAWLIB.m_pageToCanvasCoords;
    onePic.pageToAnyCanvasWindowCoords = DRAWLIB.m_pageToAnyCanvasWindowCoords;
    onePic.pageToWindowCoords = DRAWLIB.m_pageToWindowCoords;
    onePic.windowToCanvasArray = DRAWLIB.m_windowToCanvasArray;
    onePic.pageToWindowDistance = DRAWLIB.m_pageToWindowDistance;
    onePic.canvasToWindowOffset = DRAWLIB.m_canvasToWindowOffset;
    onePic.p_canvasToWindowCoords = DRAWLIB.p_canvasToWindowCoords;
    onePic.canvasToWindowRect = DRAWLIB.m_canvasToWindowRect;
    onePic.windowToCanvasScale = DRAWLIB.m_windowToCanvasScale;
    onePic.p_windowToCanvasDistance = DRAWLIB.p_windowToCanvasDistance;
    onePic.windowToCanvasCoords = DRAWLIB.m_windowToCanvasCoords;
    onePic.windowToCanvasRect = DRAWLIB.m_windowToCanvasRect;
    onePic.p_windowToCanvasContextScale = DRAWLIB.p_windowToCanvasContextScale;
    onePic.p_windowToCanvasContextCoords = DRAWLIB.p_windowToCanvasContextCoords;
    onePic.p_windowToCanvasContextRect = DRAWLIB.p_windowToCanvasContextRect;
    onePic.p_windowToCanvasContextArray = DRAWLIB.p_windowToCanvasContextArray;
    onePic.p_setItem = DRAWLIB.p_setItemPic;
    onePic.deleteItem = DRAWLIB.m_deleteItemPic;
    onePic.pick = DRAWLIB.m_pickPic;
    onePic.checkPickItem = DRAWLIB.m_checkPickItemPic;
    onePic.contained = DRAWLIB.m_containedPic;
    onePic.drawPoint = DRAWLIB.m_drawPoint;
    onePic.completeGroups = DRAWLIB.m_completeGroupsPic;
    onePic.getItemById = DRAWLIB.m_getItemById;
    onePic.getItemByDBId = DRAWLIB.m_getItemByDBId;
    onePic.setLayerVisibility = DRAWLIB.m_setLayerVisibility;
    onePic.setLayerPickable = DRAWLIB.m_setLayerPickable;
    onePic.setLayerZOffset = DRAWLIB.m_setLayerZOffset;
    onePic.getCtxt = DRAWLIB.m_getCtxt;
    onePic.getCanvasWidth = DRAWLIB.m_getCanvasWidth;
    onePic.getWindow = DRAWLIB.m_getWindow;
    //
    onePic.createItemFromJSON = DRAWLIB.m_createItemFromJSON;
    onePic.createRect = DRAWLIB.m_createRect;
    onePic.createEllipse = DRAWLIB.m_createEllipse;
    onePic.createText = DRAWLIB.m_createText;
    onePic.createImage = DRAWLIB.m_createImage;
    onePic.createPolyline = DRAWLIB.m_createPolyline;
    onePic.createFreehand = DRAWLIB.m_createFreehand;
    onePic.createPolygon = DRAWLIB.m_createPolygon;
    //
    onePic.p_createGroupBasic = DRAWLIB.p_createGroupBasic;
    onePic.createGroupFromDB = DRAWLIB.m_createGroupFromDB;
    onePic.createGroupFromPic = DRAWLIB.m_createGroupFromPic;
    //
    onePic.p_backgroundImage = undefined;
    onePic.addBackgroundImage = DRAWLIB.m_addBackground;
    onePic.p_backgroundImage4 = undefined;
    onePic.addBackgroundImage4 = DRAWLIB.m_addBackground4;
    //
    DRAWLIB.p_IMGINFO.redrawObj = onePic;
    return onePic;
    };

/**
 * pic.getCtxt returns the canvas drawing context
 *
 * @return drawing context
 */
DRAWLIB.m_getCtxt = function() { return this.p_ctxt; };

/**
 * pic.getCanvasWidth returns the width of the main canvas for drawing
 *
 * @return drawing canvas width
 */
DRAWLIB.m_getCanvasWidth = function() { return this.p_canvasWidth; };

/**
 * pic.getWindow returns the current window
 *
 * @return drawing window
 */
DRAWLIB.m_getWindow = function() { return this.p_window; };

/**
 * pic.setRedrawFunc sets a function callback to be used in place of
 * redrawall. It is optional.
 *
 * @param func A function that can be called with parameters pic, ctxt, canvas, window
 */
DRAWLIB.m_setRedrawFunc = function(func) { this.p_redrawFunc = func; };

DRAWLIB.p_setItemPic = function(item) {
    this.p_items[item.p_id] = item;
    };

/**
 * pic.deleteItem deletes an item from the drawing list.
 *
 * @param id id of the item to be deleted.
 */
DRAWLIB.m_deleteItemPic = function(id) {
    var dbId = this.p_items[id];
    delete this.p_items[id];
    if (dbId) { delete this.p_itemsById[id]; }
    };

/**
 * pic.getItemById returns an item based on the local id
 *
 * @param id Local id of the item
 * @return the item, or undef
 */
DRAWLIB.m_getItemById = function(id) { return this.p_items[id]; };

/**
 * pic.Pick finds an item, if any at a page point
 *
 * @param pX X co-ordinate of the pick point
 * @param pY Y co-ordinate of the pick point
 * @return the picked item, or undef if none found.
 */ 
DRAWLIB.m_pickPic = function(pX, pY) {
    var winPos = this.pageToWindowCoords( pX, pY);
    var pickedItem; // = undefined
    var pickedZ;
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            if (item.p_drawable && item.p_visible && item.p_pickable &&
                item.pick(winPos[0], winPos[1])) {
                if (pickedItem) {
                    if (item.p_z > pickedZ) {
                        pickedItem = item;
                        pickedZ = item.p_z;
                        }
                    }
                else {
                    pickedItem = item;
                    pickedZ = item.p_z;
                    }
                }
            }
        }
    return pickedItem;
    };

/**
 * pic.checkPickItem take a page point and an item and checks if it would be
 * picked.
 *
 * @param pX X co-ordinate of the pick point
 * @param pY Y co-ordinate of the pick point
 * @param item The item being checked
 * @return true if the point matches the item.
 */
DRAWLIB.m_checkPickItemPic = function(pX, pY, item) {
    var winPos = this.pageToWindowCoords( pX, pY);
    if (item.p_drawable && item.p_visible && item.p_pickable &&
        item.pick(winPos[0], winPos[1])) { return true; }
    return false;
    };

/**
 * pic.contained is given a rectangle on the page and returns a list of
 * items contained within the rectangle, if any.
 *
 * @param layer The layer on which to find items
 * @param x1 One X limit of the rectangle 
 * @param y1 One Y limit of the rectangle 
 * @param x2 One X limit of the rectangle 
 * @param y2 One Y limit of the rectangle 
 * @return list of contained items (empty if none)
 */
DRAWLIB.m_containedPic = function(layer, x1, y1, x2, y2) {
    // Convert to window co-ords
    var wP1 = this.pageToWindowCoords( x1, y1 );
    var wP2 = this.pageToWindowCoords( x2, y2 );
    var xMin = Math.min(wP1[0], wP2[0]);
    var xMax = Math.max(wP1[0], wP2[0]);
    var yMin = Math.min(wP1[1], wP2[1]);
    var yMax = Math.max(wP1[1], wP2[1]);
    var containedItems = [];
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var oneItem = this.p_items[itemName];
            if (oneItem.p_layer === layer && oneItem.p_drawable &&
                oneItem.p_visible && oneItem.p_pickable) {
                var BB = oneItem.p_pickBB;
                if ((xMin<=BB[0]) && (xMax>=BB[2]) &&
                    (yMin<=BB[1]) && (yMax>= BB[3])) {
                    containedItems.push(oneItem);
                    }
                }
            }
        }
    return containedItems;
    };

/**
 * pic.getMinZ returns the minimum Z value for any item.
 *
 * @return Z
 */
DRAWLIB.m_getMinZ = function() { return this.p_minZ; };

/**
 * pic.getMaxZ returns the maximum Z value for any item.
 *
 * @return Z
 */
DRAWLIB.m_getMaxZ = function() { return this.p_maxZ; };

/**
 * pic.setZ informs the pic that a Z value has been used and allows it to
 * update its minimum and maximum Z values.
 *
 * @param zVal Z value that has been applied.
 */
DRAWLIB.m_setZPic = function(zVal) {
    if (zVal < this.p_minZ) { this.p_minZ = zVal; }
    if (zVal > this.p_maxZ) { this.p_maxZ = zVal; }
    };

/**
 * pic.getItemByDBId returns the item with the given store id.
 *
 * @param dbId Store id of the desired item
 * @return relevant item (or undef if none)
 */
DRAWLIB.m_getItemByDBId = function( dbId ) { return this.p_itemsById[''+dbId]; };

/**
 * pic.completeGroups is called when creating a picture from stored information.
 * It causes all groups containing items from store to be completed.
 */
DRAWLIB.m_completeGroupsPic = function() {
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            if (item.getType() === 'G') { item.setGroupMembersFromDBId() ;}
            }
        }
    };

/**
 * pic.setLayerVisibility sets the visibility for all items on a layer.
 * By default all items are visible.
 *
 * @param layer The layer number affected
 * @param visible The visibility value
 */
DRAWLIB.m_setLayerVisibility = function( layer, visible ) {
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var oneItem = this.p_items[itemName];
            if (oneItem.p_layer === layer) { oneItem.p_visible = visible; }
            }
        }
    };

/**
 * pic.setLayerPickable sets the pickability for all items on a layer.
 * By default, all items are pickable.
 *
 * @param layer The layer number affected
 * @param visible The pickability value
 */
DRAWLIB.m_setLayerPickable = function( layer, pickable ) {
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
	    var oneItem = this.p_items[itemName];
	    if (oneItem.p_layer === layer) { oneItem.p_pickable = pickable; }
	    }
        }
    };

/**
 * pic.setLayerZOffset applies a Z offset to all items in a layer.
 * Unfortunately, this might repeat through storage so use with care.
 *
 * @param layer The layer number affected
 * @param zOffset The Z offset to apply
 */
DRAWLIB.m_setLayerZOffset = function( layer, zOffset ) {
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
	    var oneItem = this.p_items[itemName];
	    if (oneItem.p_layer === layer) {oneItem.setZ(oneItem.p_z+zOffset); }
	    }
        }
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Set the clipping region based on a rectangular bounding box
// Remember to save and restore the context when using this or clipping
// regions combine.
// TODO this doesn't work with text so I really need to replace this approach
// with drawing sections by creating an in-memory canvas, setting its
// globalCompositeOperation to 'source-in' writing to that and then
// use drawImage to copy the in-memory canvas to the main canvas.
DRAWLIB.p_setClip = function(ctxt, minX, minY, maxX, maxY) {
    ctxt.beginPath();
    ctxt.moveTo(minX, minY);
    ctxt.lineTo(minX, maxY);
    ctxt.lineTo(maxX, maxY);
    ctxt.lineTo(maxX, minY);
    ctxt.lineTo(minX, minY);
    ctxt.clip();
    };

/**
 * pic.redrawAll redraws the picture in the main canvas
 */
DRAWLIB.m_redrawAll = function() {
    this.redrawAllToCanvas(this.p_canvas, this.p_window);
    };

/**
 * pic.redrawAllToCanvas redraws the picture in a supplied canvas
 */
DRAWLIB.m_redrawAllToCanvas = function(canvas, window) {
    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;
    var ctxt = canvas.getContext("2d");
    if (this.p_redrawFunc) {
        this.p_redrawFunc(this, ctxt, canvasWidth, canvasHeight, window);
        return;
        }
    ctxt.fillStyle = this.p_background;
    ctxt.fillRect(0, 0, canvasWidth, canvasHeight);
    this.p_drawItemsByZ(this.p_items, ctxt, canvasWidth, window) ;
    ctxt.strokeStyle = '#000000';
    ctxt.lineWidth = 3;
    ctxt.strokeRect(1, 1, canvasWidth-2, canvasHeight-2); 
    };

DRAWLIB.p_redrawOneFrame = function() {
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = '#000000';
    ctxt.lineWidth = 3;
    ctxt.strokeRect(1, 1, this.p_canvas.width-2, this.p_canvas.height-2); 
    };

/**
 * pic.redrawAllToImageWindow redraws the picture to a new browser window
 */
DRAWLIB.m_redrawAllToImageWindow = function() {
    var canvas = document.createElement("canvas");
    var canvasWidth = this.p_windowBoundary[2];
    var canvasHeight = this.p_windowBoundary[3];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    var myWindow = this.p_windowBoundary;
    // Check for undefined window boundary
    if (!myWindow) { myWindow = this.p_window; }
    this.redrawAllToCanvas(canvas, myWindow);
    window.open(canvas.toDataURL("image/png"),"Image Window");
    };

/**
 * pic.blank blanks the canvas window and doesn't draw any layers.
 *
 * @param ctxt Drawing context
 * @param canvasWidth Width of canvas
 * @param canvasHeight Height of canvas
 */
DRAWLIB.m_blank = function(ctxt, canvasWidth, canvasHeight, window) {
    ctxt.fillStyle = this.p_background;
    ctxt.fillRect(0, 0, canvasWidth, canvasHeight);
    // Possible background images
    if (this.p_backgroundImage) {
        this.p_backgroundImage.draw(ctxt, canvasWidth, canvasHeight, window);
        }
    if (this.p_backgroundImage4) {
        this.p_backgroundImage4.draw(ctxt, canvasWidth, canvasHeight, window);
        }
    };

/**
 * pic.blankCanvasRect blanks a rectangle on the canvas.
 * @param xMin Minimum X co-ord
 * @param xMax Maximum X co-ord
 * @param yMin Minimum Y co-ord
 * @param yMax Maximum Y co-ord
 */
DRAWLIB.m_blankCanvasRect = function(xMin, yMin, xMax, yMax) {
    this.p_ctxt.fillStyle = this.p_background;
    this.p_ctxt.fillRect(xMin, yMin, (xMax-xMin), (yMax-yMin));
    };

/**
 * pic.redrawFrame draws a frame arpound the supplied context
 *
 * @param ctxt Drawing context
 * @param canvasWidth width of canvas
 * @param window window
 */
DRAWLIB.m_redrawFrame = function(ctxt, canvasWidth, canvasHeight) {
    ctxt.strokeStyle = '#000000';
    ctxt.lineWidth = 3;
    ctxt.strokeRect(0, 0, canvasWidth, canvasHeight); 
    };

/**
 * pic.redrawLayer redraws one layer in the supplied context.
 * Nothing is blanked first.
 *
 * @param layer The layer to redraw.
 */
DRAWLIB.m_redrawLayer = function(layer, ctxt, canvasWidth, window) {
    // Create a list of items from the aforesaid layer
    var lItems = {};
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            if ( item.p_layer === layer ) { lItems[itemName] = item; }
            }
        }
    this.p_drawItemsByZ(lItems, ctxt, canvasWidth, window) ;
    };

// Redraws a section of the picture on the main canvas.
DRAWLIB.p_redrawSectionWindow = function(minX, minY, maxX, maxY) {
    var pRect = this.windowToCanvasRect( minX, minY, maxX, maxY );
    var ctxt = this.p_ctxt;
    ctxt.fillStyle = this.p_background;
    ctxt.fillRect(pRect[0], pRect[1], pRect[2]-pRect[0], pRect[3]-pRect[1]);
    // Redraw items in the area
    var sectionItems = {};
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            // If we are dragging an item then it will
            // be redrawn separately
            if (item.p_drawable && item.p_visible && !item.p_dragging) {
                var BB = item.p_pickBB ;
                if (BB[0] <= maxX && BB[1] <= maxY && 
                    BB[2] >= minX && BB[3] >= minY) {
                    sectionItems[item.p_id] = item;
                    }
                }
            }
        }
    ctxt.save();
    this.p_setClip(ctxt, pRect[0], pRect[1], pRect[2], pRect[3]);
    this.p_drawItemsByZ(sectionItems, ctxt, this.p_canvasWidth, this.p_window) ;
    ctxt.restore();
    };

/**
 * pic.redrawSectionWindowLayer redraws a section of one layer in the
 * main canvas.
 * It chooses what to redraw based on a list of bounding boxes and it returns
 * the list with the bounding boxes of any items drawn.
 *
 * @param layer Number of the layer to draw
 * @param BBList Array of bounding boxes (minX, minY, maxX, MaxY)
 * @return updated array with more bounding boxes
 */
DRAWLIB.m_redrawSectionWindowLayer = function(layer, BBList) {
    var BBLen = BBList.length;
    var newBB = [];
    for (var i = 0 ; i < BBLen ; i++) { newBB.push(BBList[i]); }
    // calculate a total BB (because of clipping rectangle)
    var tBB = BBList[0];
    for (i = 1 ; i < BBLen ; i++ ) {
        var aBB = BBList[i];
        tBB[0] = Math.min( tBB[0], aBB[0] );
        tBB[1] = Math.min( tBB[1], aBB[1] );
        tBB[2] = Math.max( tBB[2], aBB[2] );
        tBB[3] = Math.max( tBB[3], aBB[3] );
        }
    // Redraw items in the area
    var count = 0;
    var sectionItems = {};
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            // If we are dragging an item then it will be redrawn separately
            if (item.p_drawable && item.p_visible && !item.p_dragging &&
                item.p_layer === layer) {
                var iBB = item.p_pickBB ; // BB of candidate item
                // Compare the item with total BB
                if (iBB[0] <= tBB[2] && iBB[1] <= tBB[3] && 
                    iBB[2] >= tBB[0] && iBB[3] >= tBB[1]) {
                    count += 1;
                    sectionItems[item.p_id] = item;
                    }
                }
            }
        }
    if (count > 0) {
        var cRect = this.windowToCanvasRect(tBB[0], tBB[1], tBB[2], tBB[3]);
        var cXMin = Math.min(cRect[0], cRect[2]);
        var cXMax = Math.max(cRect[0], cRect[2]);
        var cYMin = Math.min(cRect[1], cRect[3]);
        var cYMax = Math.max(cRect[1], cRect[3]);
        this.p_ctxt.save();
        this.p_setClip(this.p_ctxt, cXMin-1, cYMin-1, cXMax+1, cYMax+1);
        this.p_drawItemsByZ(sectionItems, this.p_ctxt,
                            this.p_canvasWidth, this.p_window) ;
        this.p_ctxt.restore();
        }
    // return the list of bounding boxes with new ones added
    return newBB;
    };

// Redraws a section of the picture on the main canvas.
DRAWLIB.p_redrawSectionCanvas = function(x1, y1, x2, y2) { // Canvas limits
    var canMinX = Math.min(x1, x2);
    var canMinY = Math.min(y1, y2);
    var canMaxX = Math.max(x1, x2);
    var canMaxY = Math.max(y1, y2);
    var canWid = Math.abs(x2-x1);
    var canHgt = Math.abs(y2-y1);
    // Blank the rectangle
    var ctxt = this.p_ctxt;
    ctxt.save();
    ctxt.fillStyle = this.p_background;
    this.p_setClip(ctxt, canMinX, canMinY, (canMinX+canWid), (canMinY+canHgt));
    ctxt.fillRect(canMinX, canMinY, canWid, canHgt);
    // Work out dimensions in window co-ords
    var wRect = this.canvasToWindowRect( canMinX, canMinY, canMaxX, canMaxY);
    // Redraw items in the area
    var sectionItems = {};
    for (var itemName in this.p_items) {
        if (this.p_items.hasOwnProperty(itemName)) {
            var item = this.p_items[itemName];
            if (item.p_drawable && item.p_visible) {
                var pickBB = item.p_pickBB ;
                if (pickBB[0] <= wRect[2] && pickBB[1] <= wRect[3] && 
                    pickBB[2] >= wRect[0] && pickBB[3] >= wRect[1]) {
                    sectionItems[item.p_id] = item;
                    }
                }
            }
        }
    this.p_drawItemsByZ(sectionItems, ctxt, this.p_canvasWidth, this.p_window) ;
    ctxt.restore();
    };

/**
 * pic.redrawSectionPage redraws a section of the picture in the main canvas
 *
 * @param minX Minimum X of section in page co-ordinates
 * @param minY Minimum Y of section in page co-ordinates
 * @param maxX Maximum X of section in page co-ordinates
 * @param maxY Maximum Y of section in page co-ordinates
 */
DRAWLIB.m_redrawSectionPage = function(x1, y1, x2, y2) {
    var minX = Math.min(x1, x2) -1 - this.p_canvasOffset[0];
    var maxX = Math.max(x1, x2) +1 - this.p_canvasOffset[0];
    var minY = Math.min(y1, y2) -1 - this.p_canvasOffset[1];
    var maxY = Math.max(y1, y2) +1 - this.p_canvasOffset[1];
    this.p_redrawSectionCanvas(minX, minY, maxX, maxY);
    };

/**
 * item.blankOffset blanks an area based on an offset of the item's
 * bounding box. It returns the area blanked in window co-ords.
 *
 * @param xOff - X offset in canvas co-ords
 * @param yOff - Y offset in canvas co-ords
 *
 * @return 4 element array, [minX, minY, maxX, maxY]
 */
DRAWLIB.m_blankOffset = function(xOff, yOff) {
    var ctxt = this.p_pic.p_ctxt;
    var lw = this.p_lineWidth;
    var BB = this.p_pickBB;
    // get the bounding box in canvas coords
    var cBB = this.p_pic.windowToCanvasRect(
        BB[0]-lw, BB[1]-lw, BB[2]+lw, BB[3]+lw);
    // Offset the box in canvas co-ords
    // And allow an extra pixel for rounding errors
    cBB[0] += xOff-1;
    cBB[1] += yOff-1;
    cBB[2] += xOff+1;
    cBB[3] += yOff+1;
    // Blank the rectangle
    ctxt.fillStyle = this.p_pic.p_background;
    ctxt.fillRect( cBB[0], cBB[1], cBB[2]-cBB[0], cBB[3]-cBB[1]);
    if (this.p_pic.p_backgroundImage) {
        this.p_pic.p_backgroundImage.drawBackgroundCanvasSect(cBB);
        }
    var wOff = this.p_pic.canvasToWindowOffset(xOff, yOff);
    return [BB[0]+wOff[0]-lw, BB[1]+wOff[1]-lw,
            BB[2]+wOff[0]+lw, BB[3]+wOff[1]+lw];
    } ;

/* Blank and redraw the area under an offset item */
DRAWLIB.p_redrawOffset = function(xOff, yOff) {
    var wOff = this.p_pic.canvasToWindowOffset(xOff, yOff);
    var ctxt = this.p_pic.p_ctxt;
    var lw = this.p_lineWidth;
    var BB = this.p_pickBB;
    this.p_pic.p_redrawSectionWindow(BB[0]-lw-1+wOff[0], BB[1]-lw-1+wOff[1],
                                     BB[2]+lw+1+wOff[0], BB[3]+lw+1+wOff[1]);
    } ;

/**
 * pic.drawDragRect draws a rectangle being dragged.
 * It is called repeatedly and blanks the previous rectangle.
 *
 * @param x1 X co-ordinate of one rectangle corner
 * @param y1 Y co-ordinate of one rectangle corner
 * @param oldX2 X co-ordinate of previous other rectangle corner
 * @param oldY2 Y co-ordinate of previous other rectangle corner
 * @param newX2 X co-ordinate of new other rectangle corner
 * @param newY2 Y co-ordinate of new other rectangle corner
 */
DRAWLIB.m_drawDragRect = function(x1, y1, oldX2, oldY2, newX2, newY2, lineStyle) {
    this.redrawSectionPage(x1, y1, oldX2, oldY2);
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = lineStyle;
    ctxt.lineWidth = 1;
    ctxt.beginPath();
    ctxt.moveTo(x1-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.lineTo(x1-this.p_canvasOffset[0], newY2-this.p_canvasOffset[1]);
    ctxt.lineTo(newX2-this.p_canvasOffset[0], newY2-this.p_canvasOffset[1]);
    ctxt.lineTo(newX2-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.lineTo(x1-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * pic.drawPageRect draws a rectangle in page co-ordinates
 *
 * @param x1 X co-ordinate of one rectangle corner
 * @param y1 Y co-ordinate of one rectangle corner
 * @param x2 X co-ordinate of other rectangle corner
 * @param y2 Y co-ordinate of other rectangle corner
 */
DRAWLIB.m_drawPageRect = function(x1, y1, x2, y2, lineStyle) {
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = lineStyle;
    ctxt.lineWidth = 1;
    ctxt.beginPath();
    ctxt.moveTo(x1-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.lineTo(x1-this.p_canvasOffset[0], y2-this.p_canvasOffset[1]);
    ctxt.lineTo(x2-this.p_canvasOffset[0], y2-this.p_canvasOffset[1]);
    ctxt.lineTo(x2-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.lineTo(x1-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * pic.drawDragEllipse draws an ellipse being dragged.
 * It is called repeatedly and blanks the previous rectangle.
 *
 * @param x1 X co-ordinate of one rectangle corner
 * @param y1 Y co-ordinate of one rectangle corner
 * @param oldX2 X co-ordinate of previous other rectangle corner
 * @param oldY2 Y co-ordinate of previous other rectangle corner
 * @param newX2 X co-ordinate of new other rectangle corner
 * @param newY2 Y co-ordinate of new other rectangle corner
 */
DRAWLIB.m_drawDragEllipse = function(x1, y1, oldX2, oldY2, newX2, newY2,
    lineStyle) {
    this.redrawSectionPage(x1, y1, oldX2, oldY2);
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = lineStyle;
    ctxt.lineWidth = 1;
    ctxt.beginPath();
    var midX = (x1+newX2)/2 - this.p_canvasOffset[0] ;
    var midY = (y1+newY2)/2 - this.p_canvasOffset[1] ;
    var radius = (Math.min(Math.abs(newX2-x1), Math.abs(newY2-y1)))/2;
    ctxt.arc( midX, midY, radius, 0, 2*Math.PI, false) ;
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * pic.drawPageLine draws a line between points in page co-ordinates.
 *
 * @param x1 X co-ordinate of the first point
 * @param y1 Y co-ordinate of the first point
 * @param x2 X co-ordinate of the second point
 * @param y2 Y co-ordinate of the second point
 */
DRAWLIB.m_drawPageLine = function( x1, y1, x2, y2, lineStyle, lineWidth) {
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = lineStyle;
    ctxt.lineWidth = lineWidth;
    ctxt.beginPath();
    ctxt.moveTo(x1-this.p_canvasOffset[0], y1-this.p_canvasOffset[1]);
    ctxt.lineTo(x2-this.p_canvasOffset[0], y2-this.p_canvasOffset[1]);
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * pic.drawPoint draws a small mark at a point in window co-ordinates.
 *
 * @param winX Point X co-ordinate
 * @param winY Point Y co-ordinate
 */
DRAWLIB.m_drawPoint = function(winX, winY) { //For debugging purposes
    var canP = this.windowToCanvasCoords( winX, winY );
    var ctxt = this.p_ctxt;
    ctxt.strokeStyle = '#000000';
    ctxt.lineWidth = 3;
    ctxt.beginPath();
    ctxt.moveTo(canP[0]-4, canP[1]-4);
    ctxt.lineTo(canP[0]+4, canP[1]+4);
    ctxt.moveTo(canP[0]-4, canP[1]+4);
    ctxt.lineTo(canP[0]+4, canP[1]-4);
    ctxt.stroke();
    ctxt.closePath();
    };

// Allows an array of numbers to be sorted
DRAWLIB.p_numericItemSort = function(a, b){ return (a - b); };

// Given a list of drawing iems to draw, draw them in ascending Z order.
// Z values are assumed to be positive or negative integers with higher Z value
// items drawn on top of lower Z value items.
// We don't know which Z values have been used and each Z value may have
// multiple items.
DRAWLIB.p_drawItemsByZ = function(drawList, ctxt, canvasWidth, window) {
    var zValuesList = []; // List of actual Z values encountered
    // Each property will be an array of item references at the same Z value
    var itemsByZ = {};
    for (var id in drawList) {
        if (drawList.hasOwnProperty(id)) {
            var oneItem = drawList[id];
            if (oneItem.p_drawable && oneItem.p_visible) {
                var zKey = ''+oneItem.getZ();
                if (!itemsByZ[zKey]) {
                    // First time we have encountered this Z value
                    itemsByZ[zKey] = {};
                    // Numeric value, not string-ified, for sorting
                    zValuesList.push(oneItem.getZ()) ;
                    }
                itemsByZ[zKey][id] = oneItem;
                }
            }
        }
    // Get the list of Z values in order and then draw from lists in that order
    zValuesList.sort(DRAWLIB.p_numericItemSort);
    var zLen = zValuesList.length;
    for (var i = 0 ; i < zLen ; i++) {
        var oneList = itemsByZ[''+zValuesList[i]];
        for (id in oneList) {
            if (oneList.hasOwnProperty(id)) {
                oneList[id].p_draw(ctxt, canvasWidth, window);
                }
            }
        }
    };

// Compare an item bounding box with the current window.
// if it is outside then return false so no further attempt is made
// to draw the item
DRAWLIB.p_isInWindow= function( itemBB, window) {
    if (itemBB[0] > window[0]+window[2]) { return false; }
    if (itemBB[2] < window[0]) { return false; }
    if (itemBB[1] > window[1]+window[3]) { return false; }
    if (itemBB[3] < window[1]) { return false; }
    return true;
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.pageToCanvasCoords converts page co-ordinates to canvas co-ordinates
 *
 * @param pX X co-ordinates on the page
 * @param pY Y co-ordinate on the page
 * @return 2-element array of X and Y canvas co-ordinates.
 */
DRAWLIB.m_pageToCanvasCoords = function(pX, pY) {
    pX -= this.p_canvasOffset[0];
    pY -= this.p_canvasOffset[1];
    return [pX, pY];
    };

DRAWLIB.p_canvasToWindowCoords = function(pX, pY) {
    var scale, winX, winY;
    if (this.p_rotation === 0) {
        scale = this.p_window[2] / this.p_canvasWidth;
        winX = Math.round(scale * pX) ;
        winY = Math.round(scale * pY) ;
        }
    else if(this.p_rotation === 1) {
        scale = this.p_window[3] / this.p_canvasWidth;
        winX = Math.round(scale * (this.p_canvasHeight -pY));
        winY = Math.round(scale * pX);
        }
    else if(this.p_rotation === 2) {
        scale = this.p_window[2] / this.p_canvasWidth;
        winX = Math.round(scale * (this.p_canvasWidth - pX));
        winY = Math.round(scale * (this.p_canvasHeight- pY));
        }
    else if(this.p_rotation === 3) {
        scale = this.p_window[3] / this.p_canvasWidth;
        winX = Math.round(scale * pY);
        winY = Math.round(scale * (this.p_canvasWidth - pX));
        }
    return [this.p_window[0] + winX, this.p_window[1] + winY];
    };

/**
 * pic.pageToWindowCoords converts page co-ordinates to window co-ordinates
 *
 * @param pX X co-ordinates on the page
 * @param pY Y co-ordinate on the page
 * @return 2-element array of X and Y window co-ordinates.
 */
DRAWLIB.m_pageToWindowCoords = function(pX, pY) {
    pX -= this.p_canvasOffset[0];
    pY -= this.p_canvasOffset[1];
    return this.p_canvasToWindowCoords( pX, pY );
    };

/**
 * pic.canvasToWindowRect converts canvas co-ordinates to window co-ordinates
 *
 * @param xMin Min X co-ord
 * @param yMin Min Y co-ord
 * @param xMax Max X co-ord
 * @param yMax Max Y co-ord
 *
 * @return 4-element array in window coords [minX, minY, maxX, maxY]
 */
DRAWLIB.m_canvasToWindowRect = function(pXMin, pYMin, pXMax, pYMax) {
    var wMin = this.p_canvasToWindowCoords( pXMin, pYMin );
    var wMax = this.p_canvasToWindowCoords( pXMax, pYMax );
    return [wMin[0], wMin[1], wMax[0], wMax[1]];
    };

/** pic.canvasToWindowOffset converts an X and Y offset from canvas into 
 * window co-ordinates.
 *
 * @param pX X co-ordinate of the offset
 * @param pY Y co-ordinate of the offset
 * @return 2-element array with X and Y co-ordinates of the offset
 */
DRAWLIB.m_canvasToWindowOffset = function(pX, pY) {
    var scale, winX, winY;
    if (this.p_rotation === 0) {
        scale = this.p_window[2] / this.p_canvasWidth;
        winX = Math.round(scale * pX) ;
        winY = Math.round(scale * pY) ;
        }
    else if(this.p_rotation === 1) {
        scale = this.p_window[3] / this.p_canvasWidth;
        winX = -Math.round(scale * pY);
        winY = Math.round(scale * pX);
        }
    else if(this.p_rotation === 2) {
        scale = this.p_window[2] / this.p_canvasWidth;
        winX = -Math.round(scale * pX);
        winY = -Math.round(scale * pY);
        }
    else if(this.p_rotation === 3) {
        scale = this.p_window[3] / this.p_canvasWidth;
        winX = Math.round(scale * pY);
        winY = -Math.round(scale * pX);
        }
    return [winX, winY];
    };

/**
 * pic.windowToCanvasScale returns a scale factor to go between window
 * co-ordinates and canvas co-ordinates.
 *
 * @return scale factor
 */
DRAWLIB.m_windowToCanvasScale = function() {
    return this.p_windowToCanvasContextScale( this.p_canvasWidth,
                                                 this.p_window);
    };

/**
 * pic.windowToCanvasCoords is given X and Y co-ordinates in 
 * window co-ordinates and returns them in canvas co-ordinates.
 *
 * @param wX X co-ordinate
 * @param wY Y co-ordinate
 * @return 2 element array, X, Y in canvas co-ords
 */
DRAWLIB.m_windowToCanvasCoords = function(wX, wY) {
    return this.p_windowToCanvasContextCoords( wX, wY, this.p_canvasWidth,
                                                  this.p_window);
    };

DRAWLIB.p_windowToPageCoords = function(wX, wY) {
    var cPoint = this.windowToCanvasCoords( wX, wY );
    return [this.p_canvasOffset[0] + cPoint[0], this.p_canvasOffset[1] + cPoint[1]];
    };

/**
 * pic.windowToCanvasRect is given min and maxc X and Y co-ordinates in 
 * window co-ordinates and returns them in canvas co-ordinates.
 *
 * @param wXMin Minimum X co-ordinate
 * @param wYMin Minimum Y co-ordinate
 * @param wXMax Maximum X co-ordinate
 * @param wYMax Maximum Y co-ordinate
 * @return 4 element array, min X, min Y, max X, max Y in canvas co-ords
 */
DRAWLIB.m_windowToCanvasRect = function(wXMin, wYMin, wXMax, wYMax) {
    return this.p_windowToCanvasContextRect( wXMin, wYMin, wXMax, wYMax,
                                                this.p_canvasWidth,
                                                this.p_window);
    };

/**
 * pic.windowToCanvasArray converts a list of co-ordinates from window to
 * canvas co-ordinates.
 *
 * @param wP list of 2-element arrays, each containing X and Y co-ordinates
 * @return list of 2-element arrays, each containing X and Y co-ordinates
 */
DRAWLIB.m_windowToCanvasArray = function( wP ) {
    return this.p_windowToCanvasContextArray( wP, this.p_canvasWidth,
                                                 this.p_window);
    };

/**
 * pic.pageToWindowDistance converts a page or canvas distance into window units
 *
 * @param canvasDistance Distance in page or canvas units
 * @return distance in window units
 */
DRAWLIB.m_pageToWindowDistance = function(canvasDistance) {
    var scale = 1 / this.windowToCanvasScale();
    return Math.round(canvasDistance * scale);
    };

DRAWLIB.p_windowToCanvasDistance = function(windowDistance) {
    return Math.round(this.windowToCanvasScale()*windowDistance);
    };

//==========
// Methods to do window to canvas conversion for arbitrary canvases
// These all use the current rotation

DRAWLIB.p_windowToCanvasContextScale = function( canvasWidth, window) {
    var scale;
    if (this.p_rotation === 0 || this.p_rotation === 2) {
        scale = canvasWidth / window[2];
        }
    else {
        scale = canvasWidth / window[3];
        }
    return scale;
    };

DRAWLIB.p_windowToCanvasContextCoords = function(wX, wY, canvasWidth, window) {
    var scale, pX, pY;
    wX -= window[0];
    wY -= window[1];
    if (this.p_rotation === 0) {
        scale = canvasWidth / window[2];
        pX = Math.round(scale * wX);
        pY = Math.round(scale * wY);
        }
    else if(this.p_rotation === 1) {
        scale = canvasWidth / window[3];
        pX = Math.round(scale * wY);
        pY = Math.round(scale * (window[2] - wX));
        }
    else if(this.p_rotation === 2) {
        scale = canvasWidth / window[2];
        pX = Math.round(scale * (window[2] - wX));
        pY = Math.round(scale * (window[3] - wY));
        }
    else if(this.p_rotation === 3) {
        scale = canvasWidth / window[3];
        pX = Math.round(scale * (window[3] - wY));
        pY = Math.round(scale * wX);
        }
    return [pX,  pY];
    };

DRAWLIB.p_windowToCanvasContextRect = function(wXMin, wYMin, wXMax, wYMax,
    canvasWidth, window) {
    var pMin = this.p_windowToCanvasContextCoords( wXMin, wYMin,
                                                   canvasWidth, window );
    var pMax = this.p_windowToCanvasContextCoords( wXMax, wYMax,
                                                   canvasWidth, window );
    return [pMin[0], pMin[1], pMax[0], pMax[1]];
    };

DRAWLIB.p_windowToCanvasContextArray = function( wP, canvasWidth, window ) {
    var i, scale, pX, pY, wX, wY, cX, cY;
    var cP = [];
    if (this.p_rotation === 0) {
        scale = canvasWidth / window[2];
        for ( i = 0 ; i < wP.length ; i++) {
            wX = wP[i][0] - window[0];
            wY = wP[i][1] - window[1];
            cX = Math.round(scale * wX);
            cY = Math.round(scale * wY);
            cP.push([cX, cY]);
            }
        }
    else if(this.p_rotation === 1) {
        scale = canvasWidth / window[3];
        for ( i = 0 ; i < wP.length ; i++) {
            wX = wP[i][0] - window[0];
            wY = wP[i][1] - window[1];
            cX = Math.round(scale * wY);
            cY = Math.round(scale * (window[2] - wX));
            cP.push([cX, cY]);
            }
        }
    else if(this.p_rotation === 2) {
        scale = canvasWidth / window[2];
        for ( i = 0 ; i < wP.length ; i++) {
            wX = wP[i][0] - window[0];
            wY = wP[i][1] - window[1];
            cX = Math.round(scale * (window[2] - wX));
            cY = Math.round(scale * (window[3] - wY));
            cP.push([cX, cY]);
            }
        }
    else if(this.p_rotation === 3) {
        scale = canvasWidth / window[3];
        for ( i = 0 ; i < wP.length ; i++) {
            wX = wP[i][0] - window[0];
            wY = wP[i][1] - window[1];
            cX = Math.round(scale * (window[3] - wY));
            cY = Math.round(scale * wX);
            cP.push([cX, cY]);
            }
        }
    return cP;
    };

/**
 * pic.pageToAnyCanvasWindowCoords takes a page point and a supplied canvas and
 * converts the location to a window co-ordinate, assuming that the whole
 * picture is drawn in the canvas.
 *
 * @param pX Page X Co-ord
 * @param pY Page Y Co-ord
 * @param canvas Supplied canvas
 *
 * @return 2-element array X and Y Window point.
 */
DRAWLIB.m_pageToAnyCanvasWindowCoords = function( pX, pY, canvas) {
    // First find the page to canvas offset
    var curleft = 0;
    var curtop = 0;
    var obj = canvas;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
            obj = obj.offsetParent;
            } while (obj);
        }
    var cX = pX - curleft;
    var cY = pY - curtop;
    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;
    var scale, winX, winY;
    if(this.p_rotation === 0) {
        scale = this.p_windowBoundary[2] / canvasWidth;
        winX = Math.round(scale * cX) ;
        winY = Math.round(scale * cY) ;
        }
    else if(this.p_rotation === 1) {
        scale = this.p_windowBoundary[3] / canvasWidth;
        winX = Math.round(scale * (canvasHeight -cY));
        winY = Math.round(scale * cX);
        }
    else if(this.p_rotation === 2) {
        scale = this.p_windowBoundary[2] / canvasWidth;
        winX = Math.round(scale * (canvasWidth - cX));
        winY = Math.round(scale * (canvasHeight- cY));
        }
    else if(this.p_rotation === 3) {
        scale = this.p_windowBoundary[3] / canvasWidth;
        winX = Math.round(scale * cY);
        winY = Math.round(scale * (canvasWidth - cX));
        }
    return [this.p_windowBoundary[0] + winX, this.p_windowBoundary[1] + winY];
    };
//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// All methods should be created as members of this.

/**
 * pic.getRotation returns the current picture rotation.
 *
 * @return rotation clockwise in units of 90 degrees
 */
DRAWLIB.m_getRotation = function() { return this.p_rotation; };

/**
 * pic.setRotation rotates the window relative to the canvas.
 * 
 * @param rotation is the position to rotate clockwise in units of 90 degrees
 */
DRAWLIB.m_setRotation = function( rotation ) {
    if (rotation < 0 || rotation > 3) { return; }
    // Remember the scale and mid-point
    var xMid = this.p_window[0] + this.p_window[2]*0.5;
    var yMid = this.p_window[1] + this.p_window[3]*0.5;
    var scale;
    if (this.p_rotation === 0 || this.p_rotation === 2) {
        scale = this.p_window[2] / this.p_canvasWidth;
        }
    else {
        scale = this.p_window[3] / this.p_canvasWidth;
        }
    this.p_rotation = rotation;
    var xWid, yHgt;
    // reset window dimensions to same scale
    if ( rotation === 0 || rotation === 2) {
        xWid = this.p_canvasWidth * scale;
        yHgt = this.p_canvasHeight * scale;
        }
    else {
        xWid = this.p_canvasHeight * scale;
        yHgt = this.p_canvasWidth * scale;
        }
    this.setWindow( xMid-(xWid*0.5), yMid-(yHgt*0.5), xWid, yHgt );
    };

/**
 * pic.setWindow sets how much of the window is shown in the canvas.
 * It allows panning and zooming. The amount shown may be increased,
 * if necessary, to avoid skewing.
 *
 * @param minX Minimum X co-ordinate
 * @param minY Minimum Y co-ordinate
 * @param width Window width
 * @param height Window height
 */
DRAWLIB.m_setWindow = function(minX, minY, width, height) {
   var wb = this.p_windowBoundary;
    // Set scale to minimum of X and Y
    // This may get revised if we need to scale up to avoid showing
    // anything beyond the allowed area
    var scaleX, scaleY, scale, minScaleX, minScaleY;
    if (this.p_rotation === 0 || this.p_rotation === 2) {
        scaleX = width / this.p_canvasWidth;
        scaleY = height / this.p_canvasHeight;
        scale = Math.min(scaleX, scaleY);
        if (this.p_windowBoundary) { // Check if we need to scale up
            minScaleX = this.p_windowBoundary[2] / this.p_canvasWidth;
            minScaleY = this.p_windowBoundary[3] / this.p_canvasHeight;
            scale = Math.min(scale, minScaleX, minScaleY);
            }
        height = Math.round(scale * this.p_canvasHeight);
        width = Math.round(scale * this.p_canvasWidth);
        }
    else {
        scaleX = width / this.p_canvasHeight;
        scaleY = height / this.p_canvasWidth;
        scale = Math.min(scaleX, scaleY);
        if (this.p_windowBoundary) { // Check if we need to scale up
            minScaleX = this.p_windowBoundary[2] / this.p_canvasHeight;
            minScaleY = this.p_windowBoundary[3] / this.p_canvasWidth;
            scale = Math.min(scale, minScaleX, minScaleY);
            }
        height = Math.round(scale * this.p_canvasWidth);
        width = Math.round(scale * this.p_canvasHeight);
        }
    // Check within boundary
    if (this.p_windowBoundary) {
        if(minX<this.p_windowBoundary[0]) { minX = this.p_windowBoundary[0]; }
        if(minY<this.p_windowBoundary[1]) { minY = this.p_windowBoundary[1]; }
        if(width>this.p_windowBoundary[2]){ width = this.p_windowBoundary[2]; }
        if(height>this.p_windowBoundary[3]){ height = this.p_windowBoundary[3];}
        if(minX+width > this.p_windowBoundary[0]+this.p_windowBoundary[2]) {
            minX = this.p_windowBoundary[0] + this.p_windowBoundary[2] - width;
            }
        if(minY+height > this.p_windowBoundary[1]+this.p_windowBoundary[3]) {
            minY = this.p_windowBoundary[1] + this.p_windowBoundary[3] - height;
            }
        }
    this.p_window = [minX, minY, width, height];
    };

/**
 * pic.setWindowWithResize sets how much of the window is shown in the canvas.
 * It allows panning and zooming. The amount shown may be increased,
 * if necessary, to avoid skewing.
 * It may shrink the canvas to show more without skewing.
 *
 * @param minX Minimum X co-ordinate
 * @param minY Minimum Y co-ordinate
 * @param width Window width
 * @param height Window height
 */
DRAWLIB.m_setWindowWithResize = function(minX, minY, width, height) {
    var wb = this.p_windowBoundary;
    var mcWidth = this.p_maxCanvasWidth;
    var mcHeight = this.p_maxCanvasHeight;
//alert("swwr max canvas "+mcWidth+','+mcHeight+"param w,h="+width+','+height);
    var scaleX, scaleY, scale;
    // Normalise width & height against windowBoundary if necessary
    // Then calculate separate scales in X and Y based on maximum canvas
    // dimension. Choose the larger scale (that will show the greater
    // amount of the window) and then adjust the width and height for the
    // window and the canvas accordingly.
    var width2 = width;
    var height2 = height;
    if (wb) { 
        width2 = Math.min(width, wb[2]);
        height2 = Math.min(height, wb[3]);
        }
    if (this.p_rotation === 0 || this.p_rotation === 2) {
        scaleX = width2 / mcWidth;
        scaleY = height2 / mcHeight;
        scale = Math.max(scaleX, scaleY);
        height = Math.round(scale * mcHeight);
        width = Math.round(scale * mcWidth);
        }
    else { // Rotated through 90 or 270 degrees
        scaleX = width2 / mcHeight;
        scaleY = height2 / mcWidth;
        scale = Math.max(scaleX, scaleY);
        height = Math.round(scale * mcWidth);
        width = Math.round(scale * mcHeight);
        }
    // Check within boundary, we may need to truncate move the minimum point
    if (wb) {
        if(minX<wb[0]) { minX = wb[0]; }
        if(minY<wb[1]) { minY = wb[1]; }
        if(width>wb[2]){ width = wb[2]; }
        if(height>wb[3]){ height = wb[3];}
        if(minX+width > wb[0]+wb[2]) {
            minX = wb[0] + wb[2] - width;
            }
        if(minY+height > wb[1]+wb[3]) {
            minY = wb[1] + wb[3] - height;
            }
        }
    // Now set the window and also reset the canvas dimensions.
    // Note that resetting the canvas will blank it and require a redraw
    this.p_window = [minX, minY, width, height];
    if (this.p_rotation === 0 || this.p_rotation === 2) {
        this.p_canvasWidth = Math.floor(width / scale);
        this.p_canvasHeight = Math.floor(height / scale);
        } else {
        this.p_canvasWidth = Math.floor(height / scale);
        this.p_canvasHeight = Math.floor(width / scale);
    }
    this.p_canvas.width = this.p_canvasWidth;
    this.p_canvas.height = this.p_canvasHeight;
//alert("swwr win "+minX+','+minY+' '+width+','+height+' cw='+this.p_canvasWidth+','+this.p_canvasHeight);
    };

/**
 * pic.setWindowBoundary sets the maximum dimensions of the window.
 * Once this is set, zooming or panning cannot move beyond these boundaries.
 * If the window boundary is not set then zooming or panning are not
 * constrained.
 *
 * @param minX Minimum X co-ordinate
 * @param minY Minimum Y co-ordinate
 * @param width Window width
 * @param height Window height
 */
DRAWLIB.m_setWindowBoundary = function(minX, minY, width, height) {
    // Set boundaries for a drawing surface, cannot zoom or pan past this
    this.p_windowBoundary = [minX, minY, width, height];
    // Ensure that we are only viewing within the boundary
    var win = this.p_window;
    this.setWindow(win[0], win[1], win[2], win[3]);
    // rReset the QuadTree of items
    //this.QT.clear();
    //delete this.QT;
    //this.QT = createQTNode( minX, minY, minX+width, minY+width, 0, 4, this);
    //for (var id in this.items) { this.QT.insertInto(this.items[id]); }
    };

/**
 * pic.getWindowBoundary returns the maximum dimensions of the window.
 *
 * return undefined or a 4 element array, min X, min Y, width, height
 */
DRAWLIB.m_getWindowBoundary = function() {
    if (!this.p_windowBoundary) { return undefined; }
    return [this.p_windowBoundary[0], this.p_windowBoundary[1],
            this.p_windowBoundary[2], this.p_windowBoundary[3]];
    };

/**
 * pic.resetCanvasDimensions sets the canvas size and page.
 * It should be called initially and whenever the browser window is re-sized.
 * It appears to work better when the canvas is placed absolutely.
 */
DRAWLIB.m_resetCanvasDimensions = function(canvasWidth, canvasHeight) {
    var obj = this.p_canvas;
    obj.width = canvasWidth;
    obj.height = canvasHeight;
    this.p_canvasWidth = obj.width;
    this.p_canvasHeight = obj.height;
    this.p_maxCanvasWidth = obj.width;
    this.p_maxCanvasHeight = obj.height;
    obj.style.top = "0px";
    var curleft = 0;
    var curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
            obj = obj.offsetParent;
            } while (obj);
        }
    this.p_canvasOffset = [curleft, curtop];
    };

/**
 * pic.zoomIn shrinks the current window. It halves the width and height
 * while keeping the centre point.
 */
DRAWLIB.m_zoomIn = function() {
    var midX = this.p_window[0]+this.p_window[2]/2;
    var midY = this.p_window[1]+this.p_window[3]/2;
    var wid = this.p_window[2]/2;
    var hgt = this.p_window[3]/2;
    this.setWindow(midX-wid/2, midY-hgt/2, wid, hgt);
    this.redrawAll();
    };

/**
 * pic.zoomout expands the current window. It doubles the width and height
 * while trying to keep the centre point. However, the window dimensions and
 * centre may be constrained if a window boundary has been set.
 */
DRAWLIB.m_zoomOut = function() {
    var midX = this.p_window[0]+this.p_window[2]/2;
    var midY = this.p_window[1]+this.p_window[3]/2;
    var wid = this.p_window[2]*2;
    var hgt = this.p_window[3]*2;
    this.setWindow(midX-wid/2, midY-hgt/2, wid, hgt);
    this.redrawAll();
    };

/**
 * pic.pan moves the window centre while leaving the width and height
 * unchanged.
 * The new dimensions may be constrained if a window boundary has been set.
 *
 * @param direction The direction to pan in:
 * 0 = pan right
 * 1 = pan down
 * 2 = pan left
 * 3 = pan up
 */
DRAWLIB.m_panPic = function( direction ) {
    direction += this.p_rotation;
    if (direction < 0) { direction += 4; }
    if (direction > 3) { direction -= 4; }
    var midX, midY;
    var wid = this.p_window[2];
    var hgt = this.p_window[3];
    if (direction === 0) { // pan right
        midX = this.p_window[0]+this.p_window[2];
        midY = this.p_window[1]+this.p_window[3]/2;
        }
    else if (direction === 1) { // pan down
        midX = this.p_window[0]+this.p_window[2]/2;
        midY = this.p_window[1]+this.p_window[3];
        }
    else if (direction === 2) { // pan left
        midX = this.p_window[0];
        midY = this.p_window[1]+this.p_window[3]/2;
        }
    else if (direction === 3) { // pan up
        midX = this.p_window[0]+this.p_window[2]/2;
        midY = this.p_window[1];
        }
    else { return; } // Bad direction
    this.setWindow(midX-wid/2, midY-hgt/2, wid, hgt);
    this.redrawAll();
    };

/**
 * pic.panRight pans the picture to the right within the window boundaries.
 */
DRAWLIB.m_panRight = function() { this.panPic(0); };

/**
 * pic.panLeft pans the picture to the left within the window boundaries.
 */
DRAWLIB.m_panLeft = function() { this.panPic(2); };

/**
 * pic.panup pans the picture upwards within the window boundaries.
 */
DRAWLIB.m_panUp = function() { this.panPic(3); };

/**
 * pic.panDown pans the picture downwards within the window boundaries.
 */
DRAWLIB.m_panDown = function() { this.panPic(1); };

/**
 * pic.panToCentre pans the picture to have a specified centre.
 * This may be moved to keep within the window boundary
 *
 * @param midX X co-ord of new centre
 * @param midY Y co-ord of new centre
 */
DRAWLIB.m_panToCentre = function( midX, midY ) {
    var wid, hgt;
    wid = this.p_window[2];
    hgt = this.p_window[3];
    this.setWindow(midX-wid/2, midY-hgt/2, wid, hgt);
    this.redrawAll();
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

DRAWLIB.p_createGroupBasic = function(id) {
    var oneItem = {'p_pic':this, 'p_id':id, 'p_dbId':0, 'p_drawable':false,
         'p_visible':false, 'p_pickable':false, 'p_type':'G'};
    // When created live within a picture, we will have item references but the
    // items may not have database\ids yet (until they are saved). These can
    // only be filled during a save action.
    // When created from the database, we will havethe database ids but the
    // items may not have been created in the picture yet (we don't want to
    // assume creation order) so we save the database\ids and fill in the
    // references when we can.
    oneItem.p_members = []; // Array of references to items in the group
    oneItem.p_memberDbIds = []; // Array of database ids
    oneItem.p_dragging = false;
    oneItem.getId = DRAWLIB.m_getId;
    oneItem.getDbId = DRAWLIB.m_getDbId;
    oneItem.setDbId = DRAWLIB.m_setDbId;
    oneItem.getStr = DRAWLIB.m_getStrGroup;
    oneItem.getType = DRAWLIB.m_getType;
    oneItem.pick = DRAWLIB.m_pickNull;
    oneItem.setGroupMembersFromDBId = DRAWLIB.m_setGroupMembersFromDBId;
    oneItem.p_checkMembersDBIds = DRAWLIB.p_checkMembersDBIds;
    oneItem.addMember = DRAWLIB.m_addMemberGroup;
    oneItem.removeMember = DRAWLIB.m_removeMemberGroup;
    oneItem.getMembers = DRAWLIB.m_getMembersGroup;
    oneItem.clear = DRAWLIB.m_clearGroup;
    oneItem.blankOffset = DRAWLIB.m_blankOffsetGroup;
    oneItem.drawOffset = DRAWLIB.m_drawOffsetGroup;
    this.p_setItem(oneItem);
    return oneItem;
    };

/**
 * pic.createGroupFromDB creates a group from a set of storage ids.
 *
 * @param id Local identifier
 * @param memberIds Array of member identifiers
 * @return Newly created group
 */
DRAWLIB.m_createGroupFromDB = function(id, memberIds) {
    var oneItem = this.p_createGroupBasic(id);
    oneItem.p_memberDbIds = memberIds;
    return oneItem;
    };

/**
 * pic.createGroupFromPic creates a group from a set of local ids.
 *
 * @param id Local identifier
 * @param members Array of member items
 * @return Newly created group
 */
DRAWLIB.m_createGroupFromPic = function(id, members) {
    var oneGroup = this.p_createGroupBasic(id);
    //Check for trying to include items that are already in another group
    // And notify other items of the group
    var badMembers = [];
    for (var i=0 ; i < members.length ; i++) {
        var oneItem = members[i];
        if (oneItem.getGroup() ) { badMembers.push(i); }
        else { oneItem.setGroup(oneGroup); }
        }
    var oneBad = badMembers.pop();
    while (oneBad) {
        members.splice(oneBad, 1);
        oneBad = badMembers.pop();
        }
    oneGroup.p_members = members;
    return oneGroup;
    };

DRAWLIB.m_getStrGroup = function() { // Return JSON version of the object
    var members = this.p_members;
    var memArr = [];
    memArr.push('{"t":"G","m":[');
    for (var i = 0 ; i < members.length ; i++) {
        memArr.push(members[i].p_dbId+',');
        }
    memArr.push(']}');
    return memArr.join('');
    };

DRAWLIB.m_pickNull = function( x, y) { return false; };
DRAWLIB.m_offsetNull = function(xOffset, yOffset) { return; };
DRAWLIB.m_drawNull = function(ctxt, canvasWidth, window) { return; };
DRAWLIB.m_nullFunction = function() { return; };

/**
 * group.setGroupMembersFromDBId is called for a group created with a set of
 * storage ids. Once all the members have been created, it sets the members
 * list from the storage ids.
 */
DRAWLIB.m_setGroupMembersFromDBId = function() {
    // Call this when all items have been created in the picture
    var memberIds = this.p_memberDbIds;
    var members = this.p_members;
    if (members.length) { return; } // already set
    var pic = this.p_pic;
    for (var i = 0 ; i < memberIds.length ; i++) { 
        var oneItem = pic.getItemByDBId(memberIds[i]);
        if (oneItem && !oneItem.getGroup()) {
            members.push(oneItem);
            oneItem.setGroup(this);
            }
        }
    };

//Return true if all members have database ids
DRAWLIB.p_checkMembersDBIds = function() {
    var allOk = true;
    var members = this.p_members;
    for (var i = 1 ; i < members.length ; i++) { 
         if (!members[i].dbId) {
             allOk = false; // At least one does not have an id
             break;
             }
         }
    return allOk;
    };

DRAWLIB.m_addMemberGroup = function( oneMember) {
    var members = this.p_members;
    var found = false;
    for ( var i = 0 ; i < members.length ; i++) {
        if (members[i] === oneMember) { found = true; break; }
        }
    if (!found) {
        members.push(oneMember) ;
        if (oneMember) { oneMember.setGroup(this); }
        }
    };

DRAWLIB.m_removeMemberGroup = function( oneMember ){
    var members = this.p_members;
    var found = false;
    for ( var i = 0 ; i < members.length ; i++) {
        if (members[i] === oneMember) { found = true; break; }
        }
    if (found) {
        oneMember.setGroup(0);
        members.splice(i, 1) ;
        }
    };

DRAWLIB.m_getMembersGroup = function() { return this.p_members; };

DRAWLIB.m_clearGroup = function() {
    var members = this.p_members;
    for (var i = 0 ; i < members.length ; i++) { members[i].setGroup(0); }
    };

// Offsets in canvas co-ords
DRAWLIB.m_drawOffsetGroup = function(oldXOff, oldYOff, xOff, yOff, blank) {
    // This could be optimised.
    // Currently, each item's rectangle is redrawn separately.
    // This can lead to some other items being redrawn up to once per group
    // member.
    // An alternative would be to blank all the rectangles and then feed all
    // the items to be redrawn into one list, ignoring duplicates.
    var i = 0;
    var members = this.p_members;
    var memberCount = members.length;
    // Redraw each bounding box
    if (blank) {
        for (i = 0 ; i < memberCount ; i++ ) {
            members[i].p_redrawOffset( oldXOff, oldYOff);
            }
        }
    // Redraw each item in the group
    for (i = 0 ; i < memberCount ; i++ ) {
        members[i].drawOffset( oldXOff, oldYOff, xOff, yOff, false) ;
        }
    };

DRAWLIB.m_blankOffsetGroup = function(xOff, yOff) {
    var i = 0;
    var members = this.p_members;
    var memberCount = members.length;
    // Blank under each bounding box
    for (i = 0 ; i < memberCount ; i++ ) {
        members[i].p_redrawOffset( xOff, yOff);
        }
    };
//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// Factory function to create an item from saved JSON

/**
 * pic.createItemFromJSON is given a parsed JSON version of an item and
 * recreates it.
 *
 * @param data The parsed JSON for the item.
 * @param id The item id
 */
DRAWLIB.m_createItemFromJSON = function(data, id) {
    var newItem ;
    var points = [];
    var i, ps;
    if (data.t ==='R') {
        newItem = this.createRect(id, data.mx, data.my, data.w, data.h, data.a);
        }
    if (data.t ==='C') {
        newItem = this.createEllipse(id, data.mx, data.my, data.r, data.a);
        }
    if (data.t ==='PL' || data.t === 'P') {
        for ( i = 0 ; i < data.p.length ; i++ ) {
            ps = data.p[i].split('_');
            points.push([parseInt(ps[0],10), parseInt(ps[1],10)]);
            }
        newItem = this.createPolyline(id, points);
        var arrow1 = 0;
        var arrow2 = 0;
        if (data.arrow1) { arrow1 = data.arrow1; }
        if (data.arrow2) { arrow2 = data.arrow2; }
        if (data.arrow1 || data.arrow2) { newItem.setArrows( arrow1, arrow2 ); }
        }
    if (data.t ==='F') {
        for ( i = 0 ; i < data.p.length ; i++ ) {
            ps = data.p[i].split('_');
            points.push([parseInt(ps[0],10), parseInt(ps[1],10)]);
            }
        newItem = this.createFreehand(id, points);
        }
    if (data.t ==='PG') {
        for ( i = 0 ; i < data.p.length ; i++ ) {
            ps = data.p[i].split('_');
            points.push([parseInt(ps[0],10), parseInt(ps[1],10)]);
            }
        newItem = this.createPolygon(id, points, data.fs);
        }
    if (data.t ==='T') {
        var rawText =  DRAWLIB.unescapeQuotes(data.tx);
        newItem = this.createText(id, data.mx, data.my, rawText, data.a,
            data.sz);
        if (data.va) { newItem.setTextBaseline(data.va); }
        if (data.fc) { newItem.setFontColorStyle(data.fc); }
        if (data.fst) { newItem.setFontStyle(data.fst); }
        if (data.ff) { newItem.setFontFamily(data.ff); }
        }
    if (data.t ==='I') {
        newItem = this.createImage(id, data.img, data.mx, data.my, data.w,
            data.h, data.a);
        newItem.setBoxes();
        }
    if (data.t ==='G') {
        newItem = this.createGroupFromDB(id, data.m);
        }

    // Common factors, not all in all cases but fairly common
    if (newItem) {
        if (data.layer) { newItem.setLayer(data.layer); }
        if (data.z) { newItem.setZ(data.z); }
        if (data.lw) { newItem.setLineWidth(data.lw); }
        if (data.ls) { newItem.setLineStyle(data.ls); }
        if (data.fs) { newItem.setFillStyle(data.fs); }
        }
    if ( data.t === 'T' ) {
        // Set size after font size, line & fill style are set
        // The initial setBoxes() will override the size
        if (data.w) { newItem.setWidth(data.w); }
        if (data.h) { newItem.setHeight(data.h); }
        newItem.setBoxes();
        }
    return newItem;
    };

/**
 * item.getType returns a string that denotes the type of graphic item.
 *
 * @return string with the type of item, such as 'R', 'G or 'F'
 */
DRAWLIB.m_getType = function() { return this.p_type; };

/**
 * item.getId returns the local id for an item.
 *
 * @return local id
 */
DRAWLIB.m_getId = function() { return this.p_id; };

/**
 * item.getDbId returns the database id for an item. DRAWLIB does nothing with
 * this but it can be used for external storage purposes.
 *
 * @return dbId Database (or other) id
 */
DRAWLIB.m_getDbId = function() { return this.p_dbId; };

/**
 * item.setDbId sets the database id for an item. DRAWLIB does nothing with
 * this but it can be used for external storage purposes.
 *
 * @param dbId Database (or other) id
 */
DRAWLIB.m_setDbId = function(dbId) {
    this.p_dbId = dbId;
    this.p_pic.p_itemsById[''+dbId] = this;
    };


// Blank a rectangle based on a stretched bounding box
DRAWLIB.p_blankStretchRegion = function( handle, xOff, yOff) {
    var BB = this.p_pickBB;
    var diag = DRAWLIB.p_stretchPoints(handle, xOff, yOff,
        [[BB[0], BB[1]], [BB[2], BB[3]]],
         [BB[0], BB[1]], [BB[2], BB[3]]);
    // Blank the relevant rectangle.
    var lw = this.p_lineWidth;
    this.p_pic.p_redrawSectionWindow(diag[0][0]-lw-1, diag[0][1]-lw-1,
                                     diag[1][0]+lw+1, diag[1][1]+lw+1);
    };


// Transform an array of points for stretching.
// This can be used with window or canvas points as the boundaries are supplied
// by the caller
DRAWLIB.p_stretchPoints = function(handle, xOff, yOff, points, tl, br) {
    var len = points.length;
    var anchor;
    var xScale = 1;
    var yScale = 1;
    var pOut = [];
    var wid = br[0] - tl[0];
    var hgt = br[1] - tl[1];
    if (handle === 0) { // Min X Min Y
        anchor = [br[0], br[1]];
        xScale = (wid-xOff) / wid;
        yScale = (hgt-yOff) / hgt;
        }
    if (handle === 1) { // Max X Min Y
        anchor = [tl[0], br[1]];
        xScale = (wid+xOff) / wid;
        yScale = (hgt-yOff) / hgt;
        }
    if (handle === 2) { // Max X Max Y
        anchor = [tl[0], tl[1]];
        xScale = (wid+xOff) / wid;
        yScale = (hgt+yOff) / hgt;
        }
    if (handle === 3) { // Min X Max Y
        anchor = [br[0], tl[1]];
        xScale = (wid-xOff) / wid;
        yScale = (hgt+yOff) / hgt;
        }
    if (handle === 4) { // Min X Mid edge
        anchor = [br[0], br[1]]; // y part irrelevant with scale 1
        xScale = (wid-xOff) / wid;
        }
    if (handle === 5) { // Min Y Mid edge
        anchor = [br[0], br[1]]; // x part irrelevant with scale 1
        yScale = (hgt-yOff) / hgt;
        }
    if (handle === 6) { // Max X Mid edge
        anchor = [tl[0], tl[1]]; // y part irrelevant with scale 1
        xScale = (wid+xOff) / wid;
        }
    if (handle === 7) { // Max Y Mid edge
        anchor = [tl[0], tl[1]]; // x part irrelevant with scale 1
        yScale = (hgt+yOff) / hgt;
        }

    // Now transform all points accordingly
    for (var i = 0 ; i < len ; i++) {
        var x = Math.round(anchor[0] + ((points[i][0]-anchor[0])*xScale));
        var y = Math.round(anchor[1] + ((points[i][1]-anchor[1])*yScale));
        pOut[i] = [x, y];
        }
    return pOut;
    };


// Blank a region based on a stretched rectangle
DRAWLIB.p_blankStretchRect = function(handle, xOff, yOff) {
    // Convert the offset to window co-ords
    var xOffWin = this.p_pic.pageToWindowDistance(xOff);
    var yOffWin = this.p_pic.pageToWindowDistance(yOff);
    var offPtr = this.p_stretchRect(handle, xOffWin, yOffWin);

    // Recalculate the rectangle bounding box
    var ca = Math.cos(this.p_radAngle);
    var sa = Math.sin(this.p_radAngle);
    var wCos = ca * offPtr[2] /2;
    var wSin = sa * offPtr[2] /2;
    var hCos = ca * offPtr[3] /2;
    var hSin = sa * offPtr[3] /2;

    var minX = offPtr[0] - Math.abs(wCos) - Math.abs(hSin); 
    var maxX = offPtr[0] + Math.abs(wCos) + Math.abs(hSin); 
    var minY = offPtr[1] - Math.abs(hCos) - Math.abs(wSin); 
    var maxY = offPtr[1] + Math.abs(hCos) + Math.abs(wSin); 

    // Blank the relevant rectangle.
    var lw = this.p_lineWidth;
    this.p_pic.p_redrawSectionWindow(minX-lw-1, minY-lw-1,
                                     maxX+lw+1, maxY+lw+1);
    };

// For text to be stored and returned, we want to escape quotation marks
// so as to avoid injection attacks.
// We cannot use the Javascript escape function as that format gets
// re-interpreted by the http server.
// We cannot use the HTML &#xx; format as the & messes up the http server.
// So we just convert the quotes to a backslash escape form.
DRAWLIB.escapeQuotes = function(rawText) {
    var outStr = rawText.replace(/'/g, '\\\\x27');
    outStr = outStr.replace(/"/g, '\\\\x22');
    outStr = outStr.replace(/\n/g, '\\\\x0D');
    return outStr;
    };

DRAWLIB.unescapeQuotes = function(rawText) {
    var outStr = rawText.replace(/\\x27/g, "'");
    outStr = outStr.replace(/\\x22/g, '"');
    outStr = outStr.replace(/\\x0D/g, '\n');
    return outStr;
    };

/**
 * item.getZ returns the Z value for an item.
 *
 * @return the Z value
 */
DRAWLIB.m_getZ = function() { return this.p_z; };

/**
 * item.setZ sets the Z value for an item.
 * Items with a higher Z value are drawn in front of items with lower Z value.
 *
 * @param z The Z value to set
 */
DRAWLIB.m_setZ = function(z) { 
    this.p_z = Math.round(z);
    this.p_pic.setZ(z);
    };

/**
 * item.getLayer returns the drawing layer for an item.
 * Layers can be used to set whether items are visible or pickable.
 *
 * @return the layer number
 */
DRAWLIB.m_getLayer = function() { return this.p_layer; };

/**
 * item.setLayer sets the layer number for an item.
 * Items are created on layer 0 by default.
 *
 * @param layer The layer number
 */
DRAWLIB.m_setLayer = function(layer) { this.p_layer = layer; };

/*
 * item.getDrag returns the dragging flag.
 *
 * @return true or false
 */
DRAWLIB.m_getDrag = function() { return this.p_dragging; };

/**
 * item.setDrag sets a dragging flag on an item. An item with this
 * flag set will not be drawn.
 *
 * @param drag true or false
 */
DRAWLIB.m_setDrag = function(drag) { this.p_dragging = drag; };

/**
 * item.getMid returns the window position of the centre of an item.
 *
 * @return 2-element array with X and Y values
 */
DRAWLIB.m_getMid = function() { return [this.p_midX, this.p_midY]; };

/**
 * item.setMid sets the window position of the centre of an item.
 *
 * @param x X position of the centre
 * @param y Y position of the centre
 */
DRAWLIB.m_setMid = function(x, y) {
    // Check for illegal values
    if (isNaN(x) || isNaN(y)) {
        alert("Attempt to set illegal mid-point "+x+","+y);
        return;
        }
    this.p_midX = Math.round(x);
    this.p_midY = Math.round(y);
    };

/**
 * item.setNeverPickable sets an item as never pickable.
 */
DRAWLIB.m_setNeverPickable = function() { this.p_neverPickable = true; };

/**
 * item.setPickable sets an item as pickable or not.
 *
 * @param pickable Should the item be pickable
 */
DRAWLIB.m_setPickable = function(pickable) { this.p_pickable = pickable; };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.createRect creates a rectangle drawing item and adds it to the drawing
 * item list. The rectangle is created with default styles and on layer 0.
 *
 * @param id Item identifier
 * @param x X co-ordinate of the centre point
 * @param y Y co-ordinate of the centre point
 * @param p_winWidth Width of the rectangle in window units
 * @param p_winHeight Height of the rectangle in window units
 * @return the created item
 */
DRAWLIB.m_createRect = function(id, x, y, winWidth, winHeight, angle) {
    var oneRect = {'p_pic':this, 'p_id':id,
        'p_midX':Math.round(x), 'p_midY':Math.round(y), 
        'p_winWidth':winWidth, 'p_winHeight':winHeight, 'p_dbId':0,
        'p_drawable':true, 'p_pickable':true, 'p_visible':true, 'p_layer':0,
        'p_neverPickable':false, 'p_type':'R'};
    oneRect.p_strokeStyle = '#000000'; // Default black
    oneRect.p_fillStyle = ''; // Default not filled
    oneRect.p_lineWidth = 1; // Default thin
    oneRect.p_angle = angle;
    oneRect.p_radAngle = angle * Math.PI/180;
    oneRect.p_z = 0;
    oneRect.p_group = 0;
    oneRect.p_dragging = false;
    oneRect.getId = DRAWLIB.m_getId;
    oneRect.getDbId = DRAWLIB.m_getDbId;
    oneRect.setDbId = DRAWLIB.m_setDbId;
    oneRect.getDrag = DRAWLIB.m_getDrag;
    oneRect.setDrag = DRAWLIB.m_setDrag;
    oneRect.getMid = DRAWLIB.m_getMid;
    oneRect.setMid = DRAWLIB.m_setMid;
    oneRect.setBoxes = DRAWLIB.m_setBoxesRect;
    oneRect.getBorder = DRAWLIB.m_getBorder;
    oneRect.getBB = DRAWLIB.m_getBB;
    oneRect.p_draw = DRAWLIB.p_drawRect;
    oneRect.highlight = DRAWLIB.m_highlightRect;
    oneRect.drawHandles = DRAWLIB.m_drawHandlesRotation;
    oneRect.p_stretchRect = DRAWLIB.p_stretchRect;
    oneRect.drawOffset = DRAWLIB.m_drawOffsetRect;
    oneRect.drawStretch = DRAWLIB.m_drawStretchRect;
    oneRect.p_blankStretch = DRAWLIB.p_blankStretchRect;
    oneRect.stretch = DRAWLIB.m_applyStretchToRect;
    oneRect.getWidth = DRAWLIB.m_getWidth;
    oneRect.setWidth = DRAWLIB.m_setWidth;
    oneRect.getHeight = DRAWLIB.m_getHeight;
    oneRect.setHeight = DRAWLIB.m_setHeight;    
    oneRect.getRadAngle = DRAWLIB.m_getRadAngle;
    oneRect.getAngle = DRAWLIB.m_getAngle;
    oneRect.setAngle = DRAWLIB.m_setAngle;
    oneRect.getLineStyle = DRAWLIB.m_getLineStyle;
    oneRect.setLineStyle = DRAWLIB.m_setLineStyle;
    oneRect.getFillStyle = DRAWLIB.m_getFillStyle;
    oneRect.setFillStyle = DRAWLIB.m_setFillStyle;
    oneRect.getLineWidth = DRAWLIB.m_getLineWidth; 
    oneRect.setLineWidth = DRAWLIB.m_setLineWidth; 
    oneRect.getZ = DRAWLIB.m_getZ; 
    oneRect.setZ = DRAWLIB.m_setZ; 
    oneRect.getLayer = DRAWLIB.m_getLayer; 
    oneRect.setLayer = DRAWLIB.m_setLayer; 
    oneRect.offset = DRAWLIB.m_offset;
    oneRect.setNeverPickable = DRAWLIB.m_setNeverPickable;
    oneRect.blankOffset = DRAWLIB.m_blankOffset;
    oneRect.p_redrawOffset = DRAWLIB.p_redrawOffset;
    oneRect.pick = DRAWLIB.m_pickRect;
    oneRect.setPickable = DRAWLIB.m_setPickable;
    oneRect.getStr = DRAWLIB.m_getStrRect;
    oneRect.getType = DRAWLIB.m_getType;
    //oneRect.getConnectors = DRAWLIB.m_getConnectorsRect;
    //oneRect.setConnectors = DRAWLIB.m_setConnectorsRect;
    //oneRect.addConnector = DRAWLIB.m_addConnectorRect;
    //oneRect.deleteConnector = DRAWLIB.m_deleteConnectorRect;
    oneRect.getGroup = DRAWLIB.m_getGroupRect;
    oneRect.setGroup = DRAWLIB.m_setGroupRect;
    //
    this.p_setItem(oneRect);
    oneRect.setBoxes();
    return oneRect;
    };

DRAWLIB.m_getStrRect = function() { // Return JSON version of the object
    var itemStr = '{"t":"R","mx":'+this.p_midX+',"my":'+this.p_midY+
         ',"w":'+this.p_winWidth+',"h":'+this.p_winHeight+',"a":'+this.p_angle+
         ',"lw":'+this.p_lineWidth+',"ls":"'+this.p_strokeStyle+'"';
    if (this.p_layer !== 0) { itemStr += ',"layer":'+this.p_layer; }
    if (this.p_z !== 0) { itemStr += ',"z":'+this.p_z; }
    if (this.p_fillStyle) { itemStr += ',"fs":"'+this.p_fillStyle+'"';}
    //var connectors = this.getConnectors();
    //if (connectors) {
    //    itemStr += ',"connect":[';
    //    for (var i = 0 ; i < connectors.length ; i++ ) {
    //        itemStr += connectors[i]+',';
    //        }
    //    itemStr += ']';
    //    }
    itemStr += '}';
    return itemStr;
    };

/**
 * item.getLineStyle returns the item linestyle.
 *
 * @return line style
 */
DRAWLIB.m_getLineStyle = function() { return this.p_strokeStyle; };

/**
 * item.setLineStyle sets the line style for the item. The style should be
 * an HTML color.
 *
 * @param lineStyle The style to set.
 */
DRAWLIB.m_setLineStyle = function(lineStyle) {
    this.p_strokeStyle = lineStyle;
    };

/**
 * item.getLineStyle returns the item linestyle.
 *
 * @return line style
 */
DRAWLIB.m_getFillStyle = function() { return this.p_fillStyle; };

/**
 * item.setFillStyle sets the fill style for the item. The style should be
 * an HTML color.
 *
 * @param fillStyle The style to set.
 */
DRAWLIB.m_setFillStyle = function(fillStyle) {
    this.p_fillStyle = fillStyle; 
    };

/**
 * item.getLineStyle returns the item linestyle.
 *
 * @return line style
 */
DRAWLIB.m_getLineWidth = function() { return this.p_lineWidth; };

/**
 * item.setLineWidth sets the line width style for the item.
 *
 * @param lineWidth The line width to set
 */
DRAWLIB.m_setLineWidth = function(lineWidth) {
    this.p_lineWidth = Math.round(lineWidth);
    };

//DRAWLIB.m_getConnectorsRect = function() { return this.connect; }
//DRAWLIB.m_setConnectorsRect = function( aConnectArr ) { this.connect = aConnectArr; }
//DRAWLIB.m_addConnectorRect = function( connectId ) {
//    if (!this.connect) { this.connect = []; }
//    this.connect.push(connectId) ;
//    }

//DRAWLIB.m_deleteConnectorRect = function( connectId ) {
//    for (var index = 0 ; index < this.connect.length ; index++) {
//        if (this.connect[index] === connectId) { break; }
//        }
//    if (index < this.connect.length && this.connect[index] === connectId) {
//       this.connect.splice(index, 1);
//       }
//    if (this.connect.length === 0) { this.connect = undefined; }
//    }
/**
 * item.getGroup returns the group, if any for an item.
 * An item can belong to no more than one group at a time.
 *
 * @return The group that an item is in, or undef.
 */
DRAWLIB.m_getGroupRect = function() { return this.p_group; };

/**
 * item.setGroup sets the group for an item.
 *
 * @param group The group to set.
 */
DRAWLIB.m_setGroupRect = function( group ) { this.p_group = group; };

/**
 * item.setBoxes recalculates the bounding boxes for an item.
 * These are used when picking or redrawing items.
 */
DRAWLIB.m_setBoxesRect = function() {
    var radAngle = this.p_radAngle;
    var wCos = Math.cos(radAngle) * this.p_winWidth / 2;
    var wSin = Math.sin(radAngle) * this.p_winWidth / 2;
    var hCos = Math.cos(radAngle) * this.p_winHeight / 2;
    var hSin = Math.sin(radAngle) * this.p_winHeight / 2;
    this.p_border = [];
    this.p_border[0] = [this.p_midX - wCos + hSin, this.p_midY - wSin - hCos];
    this.p_border[1] = [this.p_midX + wCos + hSin, this.p_midY + wSin - hCos];
    this.p_border[2] = [this.p_midX + wCos - hSin, this.p_midY + wSin + hCos];
    this.p_border[3] = [this.p_midX - wCos - hSin, this.p_midY - wSin + hCos];
    this.p_border[4] = [this.p_border[0][0], this.p_border[0][1]];
    this.p_pickBB = [this.p_midX-Math.abs(wCos)-Math.abs(hSin),
        this.p_midY-Math.abs(wSin)-Math.abs(hCos),
        this.p_midX+Math.abs(wCos)+Math.abs(hSin),
        this.p_midY+Math.abs(wSin)+Math.abs(hCos)];
    };

/**
 * item.getBB returns a bounding box
 *
 * @return 4-element array - minX, minY, maxX, maxY
 */
DRAWLIB.m_getBB = function() {
    return this.p_pickBB;
    };

/**
 * item.getBorder returns an array of border points
 *
 * @return 5-element of 2-element arrays in window co-ords.
 */
DRAWLIB.m_getBorder = function() { return this.p_border; };

/**
 * item.getWidth returns the width in window units
 *
 * @return width
 */
DRAWLIB.m_getWidth = function() { return this.p_winWidth; };

/**
 * item.setWidth sets the width in window units
 *
 * @param width
 */
DRAWLIB.m_setWidth = function(width) { this.p_winWidth = Math.round(width); };

/**
 * item.getHeight returns the height in window units
 *
 * @return height
 */
DRAWLIB.m_getHeight = function() { return this.p_winHeight; };

/**
 * item.setHeight sets the height in window units
 *
 * @param height
 */
DRAWLIB.m_setHeight = function(height) { this.p_winHeight = Math.round(height); };

/**
 * item.getRadAngle returns the angle of rotation in Radians
 *
 * @return angle
 */
DRAWLIB.m_getRadAngle = function() { return this.p_radAngle; };

/**
 * item.getAngle returns the angle of rotation in degrees
 *
 * @return angle
 */
DRAWLIB.m_getAngle = function() { return this.p_angle; };

/**
 * item.setAngle sets the angle of rotation for an item in degrees clockwise.
 * The bounding boxes are recalculated.
 *
 * @param angle The angle to set in degrees.
 */
DRAWLIB.m_setAngle = function(angle) {
    this.p_angle = Math.round(angle);
    this.p_radAngle = this.p_angle * Math.PI/180;
    this.setBoxes();
    };

/**
 * item.offset moves the item by an X and Y amount.
 * The bounding boxes are recalculated.
 *
 * @param xOffset The X offset to apply
 * @param yOffset The Y offset to apply
 */
DRAWLIB.m_offset = function(xOffset, yOffset) {
    // Check for illegal values
    if (isNaN(xOffset) || isNaN(yOffset)) {
        alert("Atempt to set illegal offset "+xOffset+","+yOffset);
        return;
        }
    this.p_midX = Math.round(this.p_midX+xOffset);
    this.p_midY = Math.round(this.p_midY+yOffset);
    this.setBoxes();
    };

// Can be used to draw to other contexts than the default
// But we retain the underlying rotation. This might be unexpected
DRAWLIB.p_drawRect = function(ctxt, canvasWidth, window) {
    // Check for out of view in main canvas
    if (ctxt === this.p_pic.p_ctxt && 
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }
    var scale = this.p_pic.p_windowToCanvasContextScale(canvasWidth, window);
    var cMid = this.p_pic.p_windowToCanvasContextCoords(this.p_midX, this.p_midY,
                                                     canvasWidth, window);
    var winRot = this.p_pic.p_rotation;
    var canBorder = this.p_pic.p_windowToCanvasContextArray(this.p_border,
                                                         canvasWidth, window);
    var canWidth = this.p_winWidth * scale;
    var canHeight = this.p_winHeight * scale;
    // If we are filled then we need to manage rotations in order to fill
    if (this.p_fillStyle && this.p_fillStyle !== 'none') {
        ctxt.save();
        ctxt.translate(cMid[0], cMid[1]);
        ctxt.rotate(this.p_radAngle-Math.PI*winRot*0.5);
        ctxt.translate(-cMid[0], -cMid[1]);
        ctxt.fillStyle = this.p_fillStyle; 
        ctxt.fillRect( cMid[0]-canWidth/2, cMid[1]-canHeight/2,
                       canWidth, canHeight) ;
        ctxt.restore();
        }
    // We do the actual line drawing directly rather than relying on 
    // explicit rotations
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = Math.round(scale * this.p_lineWidth);
    ctxt.lineCap = "round";
    ctxt.lineJoin = "round";
    ctxt.beginPath();
    ctxt.moveTo(canBorder[0][0], canBorder[0][1]);
    for (var i = 1 ; i <= 4 ; i++) {
        ctxt.lineTo(canBorder[i][0], canBorder[i][1]);
        }
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * item.highlight draws the item with a highlight for emphasis.
 * The highlight is not retained when the picture is redrawn.
 * The style should be an HTML color.
 *
 * @param style The linestyle with which to draw the highlight.
 */
DRAWLIB.m_highlightRect = function(style) {
    var canBorder = this.p_pic.windowToCanvasArray(this.p_border);
    var ctxt = this.p_pic.p_ctxt;
    ctxt.strokeStyle = style;
    ctxt.lineWidth = 1; // Thicker leaves trails
    ctxt.beginPath();
    ctxt.moveTo(canBorder[0][0], canBorder[0][1]);
    for (var i = 1 ; i <= 4 ; i++) {
        ctxt.lineTo(canBorder[i][0], canBorder[i][1]);
        }
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * item.drawHandles draws small 'handles' on the corners and middles of sides.
 * These can then be grabbed and dragged to re-size the item.
 * For the convenience of the caller, the positions of the handles are
 * returned in canvas co-ords.
 *
 * @param style The linestyle to use to draw the handles.
 * @param hWid The width of the handles to draw, in canvas co-ordinates
 * @return an array of 2-element array points - in order:
 * top Left corner
 * top right corner
 * bottom right corner
 * bottom left corner
 * left middle side
 * top middle side
 * right middle corner
 * bottom middle corner
 * For items that cannot be skewed only the first four points are returned.
 */
DRAWLIB.m_drawHandlesRotation = function(style, hWid) {
    var wid = this.p_pic.p_windowToCanvasDistance(this.p_winWidth);
    var hgt = this.p_pic.p_windowToCanvasDistance(this.p_winHeight);
    var cMid = this.p_pic.windowToCanvasCoords(this.p_midX, this.p_midY);
    var wCos = Math.cos(this.p_radAngle) * wid / 2;
    var wSin = Math.sin(this.p_radAngle) * wid / 2;
    var hCos = Math.cos(this.p_radAngle) * hgt / 2;
    var hSin = Math.sin(this.p_radAngle) * hgt / 2;
    var hP = [];
    // Create Corner points
    hP[0] = [cMid[0] - wCos + hSin + hWid/2, cMid[1] - wSin - hCos + hWid/2];
    hP[1] = [cMid[0] + wCos + hSin - hWid/2, cMid[1] + wSin - hCos + hWid/2];
    hP[2] = [cMid[0] + wCos - hSin - hWid/2, cMid[1] + wSin + hCos - hWid/2];
    hP[3] = [cMid[0] - wCos - hSin + hWid/2, cMid[1] - wSin + hCos - hWid/2];
    // Create Mid points
    hP[4] = [(hP[3][0]+hP[0][0])/2, (hP[3][1]+hP[0][1])/2];
    hP[5] = [(hP[0][0]+hP[1][0])/2, (hP[0][1]+hP[1][1])/2];
    hP[6] = [(hP[1][0]+hP[2][0])/2, (hP[1][1]+hP[2][1])/2];
    hP[7] = [(hP[2][0]+hP[3][0])/2, (hP[2][1]+hP[3][1])/2];
    var ctxt = this.p_pic.p_ctxt;
    ctxt.fillStyle = style;
    for (var i = 0 ; i < 8 ; i++) {
	ctxt.fillRect( hP[i][0]-hWid/2, hP[i][1]-hWid/2,
            hWid, hWid);
	}
    return hP;
    };

/**
 * item.drawOffset draws an item with an offset in canvas co-ordinates.
 * This can be used when dragging an item.
 * The item is not permanently affected.
 * The method is designed to be called repeatedly as an item is dragged.
 * The offset distances are in canvas co-ordinates
 * 
 * @param oldXOff The previous X offset
 * @param oldYOff The previous Y offset
 * @param xOff X offset
 * @param yOff Y offset
 * @param blank true if the previous position should be cleared
 */
DRAWLIB.m_drawOffsetRect = function(oldXOff, oldYOff, xOff, yOff, blank) { 
    var canBorder = this.p_pic.windowToCanvasArray(this.p_border);
    var ctxt = this.p_pic.p_ctxt;
    var lw = 1; // thicker linewidths leave trails
    if (blank) { this.p_redrawOffset(oldXOff, oldYOff); } 
    // Fill if necessary
    if (this.p_fillStyle && this.p_fillStyle !== 'none') {
        var scale = this.p_pic.windowToCanvasScale();
        var cMid = this.p_pic.windowToCanvasCoords(this.p_midX, this.p_midY);
        var canWidth = this.p_winWidth * scale;
        var canHeight = this.p_winHeight * scale;
        var mid = [cMid[0]+xOff, cMid[1]+yOff];
        ctxt.save();
        ctxt.translate(mid[0], mid[1]);
        ctxt.rotate(this.p_radAngle-Math.PI*this.p_pic.p_rotation*0.5);
        ctxt.translate(-mid[0], -mid[1]);
        ctxt.fillStyle = this.p_fillStyle; 
        ctxt.fillRect( mid[0]-canWidth/2, mid[1]-canHeight/2,
            canWidth, canHeight) ;
        ctxt.restore();
        }
    // Draw a new border
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.moveTo(canBorder[0][0]+xOff, canBorder[0][1]+yOff);
    for (var i = 1 ; i < 5 ; i++) {
        ctxt.lineTo(canBorder[i][0]+xOff, canBorder[i][1]+yOff);
        }
    ctxt.stroke();
    ctxt.closePath();
    // Refresh the frame
    this.p_pic.p_redrawOneFrame();
    };

DRAWLIB.p_drawOffsetBox = function(ctxt, canvasWidth, window, xOff, yOff) { 
    var scale, cMid, canBorder;
    var winRot = this.p_pic.p_rotation;
    scale = this.p_pic.p_windowToCanvasContextScale(canvasWidth, window);
    cMid = this.p_pic.p_windowToCanvasContextCoords(this.p_midX,this.p_midY,
        canvasWidth, window);
    canBorder = this.p_pic.p_windowToCanvasContextArray(this.p_border,
        canvasWidth, window);
    if (this.p_fillStyle && this.p_fillStyle !== 'none') {
        var canWidth = this.p_winWidth * scale;
        var canHeight = this.p_winHeight * scale;
        var mid = [cMid[0]+xOff, cMid[1]+yOff];
        ctxt.save();
        ctxt.translate(mid[0], mid[1]);
        ctxt.rotate(this.p_radAngle-Math.PI*winRot*0.5);
        ctxt.translate(-mid[0], -mid[1]);
        ctxt.fillStyle = this.p_fillStyle; 
        ctxt.fillRect( mid[0]-canWidth/2, mid[1]-canHeight/2,
            canWidth, canHeight) ;
        ctxt.restore();
        }
    // Draw a new border
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = Math.round(scale * this.p_lineWidth);
    ctxt.beginPath();
    ctxt.moveTo(canBorder[0][0]+xOff, canBorder[0][1]+yOff);
    for (var i = 1 ; i < 5 ; i++) {
        ctxt.lineTo(canBorder[i][0]+xOff, canBorder[i][1]+yOff);
        }
    ctxt.stroke();
    ctxt.closePath();
    };

// The handle is an identifier for the handle that is being dragged.
// 0 to 3 are corner handles, 4 to 7 are mid side handles
// The offset distances are in window co-ordinates
// The fun ction returns with an array containing 4 values (in window co-ords)
//   mid point X and Y
//   width and height
// The rectangle rotation will be unchanged.
DRAWLIB.p_stretchRect = function( handle, xOff, yOff) {
    // To handle rotation of the rectangle, we rotate the offset to be
    // in the rectangle's co-ordinate system. We will then adjust back
    // When we drag the centre.

    var offDist = Math.sqrt(xOff*xOff + yOff*yOff);
    // Calculate offset angle in rectangle co-ords.
    var offAng1 = Math.atan2(yOff, xOff); // Offset original angle
    var offAng2 = offAng1 - this.p_radAngle;
    if (offAng2 > Math.PI) { offAng2 -= 2*Math.PI; }
    if (offAng2 < -Math.PI) { offAng2 += 2*Math.PI; }
    // Calculate xOff and yOff in rectangle co-ordinates
    var xOff2 = offDist * Math.cos(offAng2);
    var yOff2 = offDist * Math.sin(offAng2);

    // Given the handle work out scales
    var yDrag = 1;
    var widOff = this.p_winWidth;
    var hgtOff = this.p_winHeight;
    if (handle === 0) { // Min X Min Y
        widOff -= xOff2;
        hgtOff -= yOff2;
        }
    if (handle === 1) { // Max X Min Y
        widOff += xOff2;
        hgtOff -= yOff2;
        }
    if (handle === 2) { // Max X Max Y
        widOff += xOff2;
        hgtOff += yOff2;
        }
    if (handle === 3) { // Min X Max Y
        widOff -= xOff2;
        hgtOff += yOff2;
        }
    if (handle === 4) { // Min X Mid edge
        yDrag = 0;
        widOff -= xOff2;
        }
    if (handle === 5) { // Min Y Mid edge
        xOff2 = 0;
        hgtOff -= yOff2;
        }
    if (handle === 6) { // Max X Mid edge
        yDrag = 0;
        widOff += xOff2;
        }
    if (handle === 7) { // Max Y Mid edge
        xOff2 = 0;
        hgtOff += yOff2;
        }

    // Drag the mid point
    var ca = Math.cos(this.p_radAngle);
    var sa = Math.sin(this.p_radAngle);
    var xMidOff = this.p_midX + (ca*xOff2/2) - (yDrag*sa*yOff2/2);
    var yMidOff = this.p_midY + (sa*xOff2/2) + (yDrag*ca*yOff2/2);

    return [xMidOff, yMidOff, widOff, hgtOff];
    };

/**
 * item.drawStretch draws an item that is stretched in some way.
 * The handle is an identifier for the handle that is being dragged.
 * 0 to 3 are corner handles, 4 to 7 are mid side handles
 * The offset distances are in canvas co-ordinates
 * This can be used when dragging an item. 
 * The item is not permanently affected
 * The method is designed to be called repeatedly as an item is stretched.
 * 
 * @see item.drawHandles
 * @param handle the handle that has been dragged
 * @param oldXOff The previous X offset
 * @param oldYOff The previous Y offset
 * @param xOff X offset
 * @param yOff Y offset
 * @param blank true if the previous position should be cleared
 */
DRAWLIB.m_drawStretchRect = function( handle, oldXOff, oldYOff, 
                                      xOff, yOff, blank) {
    if (blank) { this.p_blankStretch( handle, oldXOff, oldYOff); } 
    // Convert the offset to window co-ords
    var xOffWin = this.p_pic.pageToWindowDistance(xOff);
    var yOffWin = this.p_pic.pageToWindowDistance(yOff);
    var offPtr = this.p_stretchRect(handle, xOffWin, yOffWin);
    // Recalculate the rectangle border
    var midP = this.p_pic.windowToCanvasCoords( offPtr[0], offPtr[1]);
    var widP = this.p_pic.p_windowToCanvasDistance(offPtr[2]);
    var hgtP = this.p_pic.p_windowToCanvasDistance(offPtr[3]);
    var ca = Math.cos(this.p_radAngle);
    var sa = Math.sin(this.p_radAngle);
    var wCos = ca * widP /2;
    var wSin = sa * widP /2;
    var hCos = ca * hgtP /2;
    var hSin = sa * hgtP /2;
    // Draw a new border
    var pt = [];
    pt[0] = [midP[0] - wCos + hSin, midP[1] - wSin - hCos];
    pt[1] = [midP[0] + wCos + hSin, midP[1] + wSin - hCos];
    pt[2] = [midP[0] + wCos - hSin, midP[1] + wSin + hCos];
    pt[3] = [midP[0] - wCos - hSin, midP[1] - wSin + hCos];
    pt[4] = [pt[0][0], pt[0][1]];
    var ctxt = this.p_pic.p_ctxt;
    var lw = 1; // thicker linewidths leave trails
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.moveTo(pt[0][0], pt[0][1]);
    for (var i = 1 ; i < 5 ; i++) {
        ctxt.lineTo(pt[i][0], pt[i][1]);
        }
    ctxt.stroke();
    ctxt.closePath();
    };

/**
 * item.stretch changes the dimensions of an item when a 'handle' has been
 * dragged.
 * The offsets are in canvas co-ords
 *
 * @see item.drawHandles
 * @param handle the handle that has been dragged
 * @param xOff X offset
 * @param yOff Y offset
 */
DRAWLIB.m_applyStretchToRect = function(handle, xOff, yOff) {
    // Convert the offset to window co-ords
    var xOffWin = this.p_pic.pageToWindowDistance(xOff);
    var yOffWin = this.p_pic.pageToWindowDistance(yOff);
    var offPtr = this.p_stretchRect(handle, xOffWin, yOffWin);
    // Amend the centre and dimensions
    this.p_midX = Math.round(offPtr[0]);
    this.p_midY = Math.round(offPtr[1]);
    this.p_winWidth = Math.round(offPtr[2]);
    this.p_winHeight = Math.round(offPtr[3]);
    this.setBoxes();
    };

// Is a point close to a line segment
DRAWLIB.p_isPointNearLine = function(x1, y1, x2, y2, xP, yP) {
    var marg = 5; // Margin of error, would be nice to scale
    // Check for the point outside the line's bounding box
    if ((xP < x1-marg) && (xP < x2-marg)) { return false; }
    if ((xP > x1+marg) && (xP > x2+marg)) { return false; }
    if ((yP < y1-marg) && (yP < y2-marg)) { return false; }
    if ((yP > y1+marg) && (yP > y2+marg)) { return false; }
    // The calculations below assume x1 != x2 so check before dividing by zero
    // If the line is almost horizontal or vertical then the BB checks are
    // adequate
    if (Math.abs(y2-y1) < marg || Math.abs(x2-x1) < marg) { return true; }
    // Calculate the perpendicular distance between the point and the line
    var m = (y2-y1)/(x2-x1); // gradient
    var b = y1 - x1*m ; // Intercept of X axis
    var dist = Math.abs(yP - m*xP - b) / Math.sqrt(1 + m*m) ;
    if (dist <= marg) { return true; }
    return false;
    };

// Return -ve, 0 or +ve for which side of the line the point is
DRAWLIB.p_pointSideOfLine = function(x1, y1, x2, y2, xP, yP) {
    var lineAngle = Math.atan2(y2-y1, x2-x1);
    var pointAngle = Math.atan2(yP-y1, xP-x1);
    var offsetAngle = pointAngle - lineAngle;
    while (offsetAngle < -Math.PI) { offsetAngle += 2*Math.PI; }
    while (offsetAngle > Math.PI) { offsetAngle -= 2*Math.PI; }
    return offsetAngle;
    };

/**
 * item.pick checks if a given point in window co-ordinates lies
 * on the item.
 *
 * @param x X co-ord
 * @param y Y co-ord
 *
 * @return true for a hit, otherrwise false
 */
DRAWLIB.m_pickRect = function(x, y) {
    if (this.p_neverPickable) { return false; }
    var BB = this.p_pickBB;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    // If the rectangle is filled and not angled then the BB check
    // is good enough
    if ((this.p_fillStyle) && (this.p_angle === 0)) { return true; }
    // If the rectangle is filled then we check for inside the angled box
    var bord, i;
    if (this.p_fillStyle) {
        bord = this.p_border;
        var side1 = DRAWLIB.p_pointSideOfLine(bord[0][0], bord[0][1],
                                              bord[1][0], bord[1][1], x, y);
        for ( i = 1 ; i < 4 ; i++){
            var side2 = DRAWLIB.p_pointSideOfLine(bord[i][0], bord[i][1],
                                        bord[i+1][0], bord[i+1][1], x, y);
            if (((side1 < 0) && (side2 > 0)) || ((side1 > 0) && (side2 < 0))) {
                return false;
                }
            if (side1 === 0) { side1 = side2; }
           }
        return true;
        }
    // If the rectangle is not filled then we need to check against each line
    if (!this.p_fillStyle) {
        bord = this.p_border;
        for ( i = 0 ; i < 4 ; i++){
            if (DRAWLIB.p_isPointNearLine(bord[i][0], bord[i][1],
                                bord[i+1][0], bord[i+1][1],
                x, y)) { return true; }
            }
        }
    return false;
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.createEllipse creates an ellipse drawing item and adds it to the drawing
 * item list. The ellipse is created with default styles and on layer 0.
 * At present, the ellipse has to be a circle.
 *
 * @param id Item identifier
 * @param x X co-ordinate of the centre point
 * @param y Y co-ordinate of the centre point
 * @param winradius radius of the ellipse
 * @return the created item
 */
DRAWLIB.m_createEllipse = function(id, x, y, winRadius, angle) {
    // Derive from Rectangle
    var oneEllipse = this.createRect(id, x, y, winRadius, winRadius, angle);
    oneEllipse.p_type = 'C';
    oneEllipse.p_radius = Math.round(winRadius);
    oneEllipse.getRadius = DRAWLIB.m_getRadius;
    oneEllipse.setRadius = DRAWLIB.m_setRadius;
    oneEllipse.setBoxes = DRAWLIB.m_setBoxesEllipse;
    oneEllipse.p_draw = DRAWLIB.p_drawEllipse;
    oneEllipse.drawHandles = DRAWLIB.m_drawHandlesNoRotation;
    oneEllipse.drawOffset = DRAWLIB.m_drawOffsetEllipse;
    oneEllipse.p_blankStretch = DRAWLIB.p_blankStretchRegion;
    oneEllipse.drawStretch = DRAWLIB.m_drawStretchEllipse;
    oneEllipse.stretch = DRAWLIB.m_applyStretchToEllipse;
    oneEllipse.pick = DRAWLIB.m_pickEllipse;
    oneEllipse.getStr = DRAWLIB.m_getStrEllipse;
    //oneImg.pick = pickImg; // Add when more selective pick
    oneEllipse.setBoxes();
    return oneEllipse;
    };

DRAWLIB.m_getStrEllipse = function() { // Return JSON version of the object
    var itemStr = '{"t":"C","mx":'+this.p_midX+',"my":'+this.p_midY+
         ',"r":'+this.p_radius+',"a":'+this.p_angle+','+
         '"lw":'+this.p_lineWidth+',"ls":"'+this.p_strokeStyle+'"';
    if (this.p_layer !== 0) { itemStr += ',"layer":'+this.p_layer; }
    if (this.p_z !== 0) { itemStr += ',"z":'+this.p_z; }
    if (this.p_fillStyle) { itemStr += ',"fs":"'+this.p_fillStyle+'"'; }
    //var connectors = this.getConnectors();
    //if (connectors) {
    //    itemStr += ',"connect":[';
    //    for (var i = 0 ; i < connectors.length ; i++ ) {
    //        itemStr += connectors[i]+',';
    //        }
    //    itemStr += ']';
    //    }
    itemStr += '}';
    return itemStr;
    };

/**
 * item.getRadius returns the radius of an item
 *
 * @return radius
 */
DRAWLIB.m_getRadius = function() { return this.p_radius; };

/**
 * item.setRadius sets the radius of an item
 *
 * @param radius
 */
DRAWLIB.m_setRadius = function( radius ) { this.p_radius = Math.round(radius); };

// Draw small 'handles' on the corners and middles of sides.
// These can then be grabbed.
// For the convenience of the caller, the positions of the
// handles are returned in canvas co-ords.
// This version is for items that cannot be rotated
// Handles are placed wholly inside the bounding box for dragging reasons
DRAWLIB.m_drawHandlesNoRotation = function(style, wid) {
    var handlePos = [];
    var BB = this.p_pickBB;
    var BBMin = this.p_pic.windowToCanvasCoords(BB[0], BB[1]);
    var BBMax = this.p_pic.windowToCanvasCoords(BB[2], BB[3]);
    // Create Corner points
    handlePos[0] = [BBMin[0]+wid/2, BBMin[1]+wid/2];
    handlePos[1] = [BBMax[0]-wid/2, BBMin[1]+wid/2];
    handlePos[2] = [BBMax[0]-wid/2, BBMax[1]-wid/2];
    handlePos[3] = [BBMin[0]+wid/2, BBMax[1]-wid/2];
    // Create Mid points
    handlePos[4] = [BBMin[0]+wid/2, (BBMin[1]+BBMax[1])/2];
    handlePos[5] = [(BBMin[0]+BBMax[0])/2, BBMin[1]+wid/2];
    handlePos[6] = [BBMax[0]-wid/2, (BBMin[1]+BBMax[1])/2];
    handlePos[7] = [(BBMin[0]+BBMax[0])/2, BBMax[1]-wid/2];
    var ctxt = this.p_pic.p_ctxt;
    ctxt.fillStyle = style;
    for (var i = 0 ; i < 8 ; i++) {
	ctxt.fillRect( handlePos[i][0]-wid/2, handlePos[i][1]-wid/2, wid, wid);
	}
    return handlePos;
    };

// Set drawing boundary and picking bounding box in real world co-ords
DRAWLIB.m_setBoxesEllipse = function() {
    this.p_border = [];
    var radius = this.p_radius;
    var midX = this.p_midX;
    var midY = this.p_midY;
    this.p_border[0] = [midX - radius, midY - radius];
    this.p_border[1] = [midX + radius, midY - radius];
    this.p_border[2] = [midX + radius, midY + radius];
    this.p_border[3] = [midX - radius, midY + radius];
    this.p_border[4] = [midX - radius, midY - radius];
    this.p_pickBB = [midX-radius, midY-radius,
                     midX+radius, midY+radius];
    };

DRAWLIB.p_drawEllipse = function(ctxt, canvasWidth, window) {
    // Can be used to draw to other contexts than the default
    // if in main window, check for out of view
    if (ctxt === this.p_pic.p_ctxt &&
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }

    var scale = this.p_pic.p_windowToCanvasContextScale( canvasWidth, window);
    var midP = this.p_pic.p_windowToCanvasContextCoords(this.p_midX, this.p_midY,
                                                     canvasWidth, window);
    var radius = this.p_radius * scale;
    // If filled then fill it
    if (this.p_fillStyle && this.p_fillStyle !== 'none') {
        ctxt.fillStyle = this.p_fillStyle;
        ctxt.beginPath();
        ctxt.arc( midP[0], midP[1], radius, 0, 2*Math.PI,false);
        ctxt.fill();
        ctxt.closePath();
        }
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = Math.round(scale * this.p_lineWidth);
    ctxt.beginPath();
    ctxt.arc( midP[0], midP[1], radius, 0, 2*Math.PI, false);
    ctxt.stroke();
    ctxt.closePath();
    };

// Offsets in canvas co-ords
DRAWLIB.m_drawOffsetEllipse = function(oldXOff, oldYOff, xOff, yOff, blank) {
    var midP = this.p_pic.windowToCanvasCoords( this.p_midX, this.p_midY);
    var window = this.p_pic.p_window;
    var scale = this.p_pic.windowToCanvasScale();
    var ctxt = this.p_pic.p_ctxt;
    var lw = 1; // Thicker linewidths leave trails
    if (blank) { this.p_redrawOffset(oldXOff, oldYOff); }
    var radius = this.p_radius * scale;
    // If filled then fill it
    if (this.p_fillStyle && this.p_fillStyle !== 'none') {
        ctxt.fillStyle = this.p_fillStyle;
        ctxt.beginPath();
        ctxt.arc( xOff + midP[0], yOff + midP[1], radius, 0, 2*Math.PI, false);
        ctxt.fill();
        ctxt.closePath();
        }
    // Draw a new border
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.arc( xOff + midP[0], yOff + midP[1], radius, 0, 2*Math.PI, false);
    ctxt.stroke();
    ctxt.closePath();
    // Refresh the frame
    this.p_pic.p_redrawOneFrame();
    };

// Is the point x,y in window co-ords a hit on the image?
DRAWLIB.m_pickEllipse = function(x, y) {
    var BB = this.p_pickBB;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    // Calculate the distance from the centre.
    var dist = Math.sqrt((x-this.p_midX)*(x-this.p_midX) + 
        (y-this.p_midY)*(y-this.p_midY));
    // If the ellipse is filled then we have a hit if we are within the radius
    if ((this.p_fillStyle) && (dist <= this.p_radius+marg)) { return true; }
    // If the ellipse is notfilled then we need to be 'close' to the radius.
    if ((!this.p_fillStyle) && (Math.abs(dist-this.p_radius) < marg)) {
        return true;
        }
    return false;
    };

// Draw a circle that is stretched in some way
// The handle is an identifier for the handle that is being dragged.
// 0 to 3 are corner handles, 4 to 7 are mid side handles
DRAWLIB.m_drawStretchEllipse = function( handle, oldXOff, oldYOff, xOff, yOff,
     blank) {
    if (blank) { this.p_blankStretch( handle, oldXOff, oldYOff); }
    var BB = this.p_pickBB;
    var cBB = this.p_pic.windowToCanvasRect( BB[0], BB[1],
                                               BB[2], BB[3]);
    var sPoints = DRAWLIB.p_stretchPoints(handle, xOff, yOff,           
        [[cBB[0], cBB[1]], [cBB[2], cBB[3]]],
        [cBB[0], cBB[1]], [cBB[2], cBB[3]]);
    var p_midX = Math.round((sPoints[0][0] + sPoints[1][0])/2);
    var p_midY = Math.round((sPoints[0][1] + sPoints[1][1])/2);
    var radius = Math.round( 0.5 * Math.min(
        (sPoints[1][0]-sPoints[0][0]), (sPoints[1][1]-sPoints[0][1])));
    // Draw a new circle
    var ctxt = this.p_pic.p_ctxt;
    var lw = 1; // thicker linewidths leave trails
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.arc( p_midX, p_midY, radius, 0, 2*Math.PI, false);
    ctxt.stroke();
    ctxt.closePath();
    };

// Apply a window offset stretch to an ellipse based on
// dragging a specific handle
// The offsets ate in canvas co-ords
DRAWLIB.m_applyStretchToEllipse = function( handle, xOff, yOff) {
    // Set up diagonal corners and stretch them.
    var BB = this.p_pickBB;
    var diag = DRAWLIB.p_stretchPoints(handle, xOff, yOff,
        [[BB[0], BB[1]], [BB[2], BB[3]]],
         [BB[0], BB[1]], [BB[2], BB[3]]);
    // Now derive the middl and radius from the diagonals
    this.p_midX = Math.round((diag[0][0]+diag[1][0])/2);
    this.p_midY = Math.round((diag[0][1]+diag[1][1])/2);
    this.p_radius = Math.round( 0.5 * Math.min(
        diag[1][0]-diag[0][0], diag[1][1]-diag[0][1]));
    this.setBoxes();
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.


/**
 * pic.creatText creates a text drawing item and adds it to the drawing
 * item list. The text is created with default styles and on layer 0.
 * If the item has a line style or fill style set then it will be drawn
 * within a box.
 * The body text can be multi-line.
 *
 * @param id Item identifier
 * @param x X co-ordinate of the centre point
 * @param y Y co-ordinate of the centre point
 * @param bodyText Text to be drawn
 * @param angle Rotation clockwise in degrees
 * @param fontSize Vertical size of the text in window co-ordinates
 * @return the created item
 */
DRAWLIB.m_createText = function(id, x, y, bodyText, angle, fontSize) {
    // Derive from Rectangle
    var oneItem = this.createRect(id, x, y, 1, 1, angle);
    oneItem.p_type = 'T';
    oneItem.p_strokeStyle = ''; // Default no text box
    oneItem.p_text = bodyText;
    oneItem.p_lineSpacing = 1.2; // 20% gap, might overwrite
    oneItem.p_breakText = DRAWLIB.p_breakText;
    oneItem.p_breakText();
    oneItem.getText = DRAWLIB.m_getText;
    oneItem.setText = DRAWLIB.m_setText;
    oneItem.p_fontFamily = 'sans';
    oneItem.p_fontStyle = ''; // normal, bold, italic
    // fill colour for font, can be different to background box
    oneItem.p_fontFillStyle = '#000000';
    oneItem.p_fontSize = Math.round(fontSize); // In window co-ords
    oneItem.p_textBaseline = 'middle';
    oneItem.p_textAlign = 'center';
    oneItem.setBoxes = DRAWLIB.m_setBoxesText;
    oneItem.p_setBoxesRect = DRAWLIB.m_setBoxesRect;
    oneItem.doDrawTextWithOffset = DRAWLIB.m_doDrawTextWithOffset;
    oneItem.p_drawOffsetRect = DRAWLIB.p_drawOffsetRect;
    oneItem.p_draw = DRAWLIB.p_drawText;
    oneItem.p_drawBox = DRAWLIB.p_drawRect; // Draw box for text in box
    oneItem.drawOffset = DRAWLIB.m_drawOffsetText;
    oneItem.p_drawOffsetBox = DRAWLIB.p_drawOffsetBox;
    oneItem.pick = DRAWLIB.m_pickText;
    oneItem.getStr =DRAWLIB.m_getStrText;
    oneItem.getFontStyle = DRAWLIB.m_getFontStyleText;
    oneItem.setFontStyle = DRAWLIB.m_setFontStyleText;
    oneItem.getFontFamily = DRAWLIB.m_getFontFamilyText;
    oneItem.setFontFamily = DRAWLIB.m_setFontFamilyText;
    oneItem.getFontSize = DRAWLIB.m_getFontSizeText;
    oneItem.setFontSize = DRAWLIB.m_setFontSizeText;
    oneItem.getFontColorStyle = DRAWLIB.m_getFontColorStyle;
    oneItem.setFontColorStyle = DRAWLIB.m_setFontColorStyle;
    oneItem.setTextBaseline = DRAWLIB.m_setTextBaseline;
    oneItem.setBoxes();
    return oneItem;
    };

DRAWLIB.m_getStrText = function() { // Return JSON version of the object
    var itemStr = '{"t":"T","mx":'+this.p_midX+',"my":'+this.p_midY+',"a":'+
        this.p_angle+',"tx":"'+DRAWLIB.escapeQuotes(this.p_text)+
        '","sz":'+this.p_fontSize+',"fc":"'+this.p_fontFillStyle+'"';
    if (this.p_textBaseline !== 'middle') {
        itemStr += ',"va":"'+this.p_textBaseline+'"';
        }
    if (this.p_fontFamily !== 'sans' ) {
        itemStr += ',"ff":"'+this.p_fontFamily+'"';
        }
    if (this.p_fontStyle ) { itemStr += ',"fst":"'+this.p_fontStyle+'"'; }
    if (this.p_lineWidth) { itemStr += ',"lw":'+this.p_lineWidth; }
    if (this.p_strokeStyle !== '') { // Has a text box
        itemStr += ',"ls":"'+this.p_strokeStyle+'","w":'+this.p_winWidth+
            ',"h":'+this.p_winHeight;
        }
    if (this.p_fillStyle) { itemStr += ',"fs":"'+this.p_fillStyle+'"'; }
    if (this.p_layer !== 0) { itemStr += ',"layer":'+this.p_layer; }
    if (this.p_z !== 0) { itemStr += ',"z":'+this.p_z; }
    itemStr += '}';
    return itemStr;
    };

// Break up body text into an array of lines
// Always call this after setting the body text.
DRAWLIB.p_breakText = function() {
    this.p_lines = this.p_text.split("\n");
    };

/**
 * item.getText returns the text of an item
 *
 * @return text as a string
 */
DRAWLIB.m_getText = function() { return this.p_text; };

/** item.setText sets the text of an item
 *
 * @param text as a string
 */
DRAWLIB.m_setText = function( text ) {
    this.p_text = text;
    this.p_breakText();
    };

// Set drawing boundary and picking bounding box in window co-ords
DRAWLIB.m_setBoxesText = function() {
    // If we have text in a box then just use the box part
    if (this.p_strokeStyle || this.p_fillStyle) {
        this.p_setBoxesRect();
        return; 
        }
    // With no box, we need the text dimensions for each line
    // This code assumes aligned center middle
    var len = this.p_text.length;
    // Font size is in window co-ords, not canvas
    var fontSize = Math.round(this.p_fontSize);
    var ctxt = this.p_pic.p_ctxt;
    ctxt.font = this.p_fontStyle+' '+fontSize+'px '+this.p_fontFamily;
    this.p_winWidth = 0;
    for (var l = 0 ; l < this.p_lines.length ; l++) {
        var metrics = ctxt.measureText(this.p_lines[l]);
        this.p_winWidth = Math.max( this.p_winWidth, metrics.width );
        }
    this.p_winHeight = this.p_fontSize * this.p_lineSpacing *
                       this.p_lines.length;
    // Precalculate numbers used more than once
    var wCos = Math.cos(this.p_radAngle) * this.p_winWidth / 2;
    var wSin = Math.sin(this.p_radAngle) * this.p_winWidth / 2;
    var hCos = Math.cos(this.p_radAngle) * this.p_winHeight / 2;
    var hSin = Math.sin(this.p_radAngle) * this.p_winHeight / 2;
    this.p_border = [];
    this.p_border[0] = [this.p_midX - wCos + hSin, this.p_midY - wSin - hCos];
    this.p_border[1] = [this.p_midX + wCos + hSin, this.p_midY + wSin - hCos];
    this.p_border[2] = [this.p_midX + wCos - hSin, this.p_midY + wSin + hCos];
    this.p_border[3] = [this.p_midX - wCos - hSin, this.p_midY - wSin + hCos];
    this.p_border[4] = [this.p_border[0][0], this.p_border[0][1]];
    this.p_pickBB = [this.p_midX-Math.abs(wCos)-Math.abs(hSin), 
        this.p_midY-Math.abs(wSin)-Math.abs(hCos),
        this.p_midX+Math.abs(wCos)+Math.abs(hSin),
        this.p_midY+Math.abs(wSin)+Math.abs(hCos)];
    };

// Draw some text with an optional offset in canvas co-ords
DRAWLIB.m_doDrawTextWithOffset = function(ctxt, canvasWidth, window, 
                                          xOff, yOff) {
    // If in main window, check for outside 
    if (ctxt === this.p_pic.p_ctxt &&
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }
    var scale = this.p_pic.p_windowToCanvasContextScale(canvasWidth, window);
    var lineOff = Math.round(this.p_fontSize*this.p_lineSpacing * scale);
    var yHalf = Math.round(lineOff * (this.p_lines.length-1) * 0.5);
    var cMid = this.p_pic.p_windowToCanvasContextCoords(this.p_midX,
                                                        this.p_midY,
                                                        canvasWidth, window);
    if (this.p_strokeStyle || this.p_fillStyle) { 
        this.p_drawOffsetBox(ctxt, canvasWidth, window, xOff, yOff);
        }
    var canWidth = this.p_winWidth * scale;
    var canHeight = this.p_winHeight * scale;
    var fontSize = Math.round(this.p_fontSize * scale);
    // cMid is the midpoint of the text. If the vertical alignment
    // is 'top' or 'bottom' then it is adjusted for the bounding box.
    // Note that if the bounding box is set based on the text itself then
    // these all vertical alignments look alike.
    // Of course, if the text or the picture are rotated then top and bottom
    // are relative to a rotated line.
    var winRot = this.p_pic.p_rotation;
    var tang = this.p_radAngle - Math.PI*winRot*0.5;
    if ((this.p_textBaseline === 'top' ) || (this.p_textBaseline === 'bottom')){
        var thalf = (canHeight*0.5) + yHalf;
        var tcos = Math.cos(tang) * thalf;
        var tsin = Math.sin(tang) * thalf;
        if (this.p_textBaseline === 'top' ) {
            cMid[0] += tsin;
            cMid[1] -= tcos;
            }
        if (this.p_textBaseline === 'bottom' ) {
            cMid[0] -= tsin;
            cMid[1] += tcos;
            }
        }
    // Now offset the position for a drag
    cMid[0] += xOff;
    cMid[1] += yOff;
    // Now do the actual drawing, rotated appropriately
    ctxt.save();
    ctxt.translate(cMid[0], cMid[1]);
    ctxt.rotate(tang);
    ctxt.translate(-cMid[0], -cMid[1]);
    // Font string is style, family and size (in pixels here)
    ctxt.font = this.p_fontStyle+' '+fontSize+'px '+this.p_fontFamily;
    ctxt.fillStyle = this.p_fontFillStyle;
    ctxt.textAlign = this.p_textAlign;
    ctxt.textBaseline = this.p_textBaseline;
    for (var l = 0 ; l < this.p_lines.length ; l++ ) {
        var y = cMid[1] - yHalf + (lineOff*l);
        ctxt.fillText(this.p_lines[l], cMid[0], y);
        }
    ctxt.restore(); 
    };

DRAWLIB.p_drawText = function(ctxt, canvasWidth, window) {
    // Can be used to draw to other contexts than the default
    if (this.p_strokeStyle || this.p_fillStyle) {
         this.p_drawBox( ctxt, canvasWidth, window);
        }
    this.doDrawTextWithOffset(ctxt, canvasWidth, window, 0, 0);
    };

// Offsets in canvas co-ords
DRAWLIB.m_drawOffsetText = function(oldXOff, oldYOff, xOff, yOff, blank) {
    var pic = this.p_pic;
    if (blank) { this.p_redrawOffset(oldXOff, oldYOff); }
    if (this.p_strokeStyle || this.p_fillStyle) { 
        this.p_drawOffsetBox(pic.p_ctxt, pic.p_canvasWidth, pic.p_window,
                             xOff, yOff);
        }
    this.doDrawTextWithOffset(pic.p_ctxt, pic.p_canvasWidth, pic.p_window,
        xOff, yOff);
    // Refresh the frame
    this.p_pic.p_redrawOneFrame();
    };

// Is the point x,y in real world co-ords a hit on the text?
DRAWLIB.m_pickText = function(x, y) {
    var BB = this.p_pickBB;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    // If the text not angled then the BB check is good enough
    if ((this.p_fillStyle !== 'none') && (this.p_angle === 0)) { return true; }
    // If we have a text box then check for within the box
    var bord, side1, side2, i;
    if (this.p_fillStyle) {
        bord = this.p_border;
        side1 = DRAWLIB.p_pointSideOfLine(bord[0][0], bord[0][1],
            bord[1][0], bord[1][1], x, y);
        for ( i = 1 ; i < 4 ; i++){
            side2 = DRAWLIB.p_pointSideOfLine(bord[i][0], bord[i][1],
                bord[i+1][0], bord[i+1][1], x, y);
            if (((side1 < 0) && (side2 > 0)) || ((side1 > 0) && (side2 < 0))) {
                return false;
                }
            if (side1 === 0) { side1 = side2; }
           }
        return true;
        }
    // At this point we have angled text with no box
    // If the text is angled then we check for inside the angled box
    bord = this.p_border;
    side1 = DRAWLIB.p_pointSideOfLine(bord[0][0], bord[0][1],
        bord[1][0], bord[1][1], x, y);
    for ( i = 1 ; i < 4 ; i++){
        side2 = DRAWLIB.p_pointSideOfLine(bord[i][0], bord[i][1],
            bord[i+1][0], bord[i+1][1], x, y);
        if (((side1 < 0) && (side2 > 0)) || ((side1 > 0) && (side2 < 0))) {
            return false;
            }
        if (side1 === 0) { side1 = side2; }
       }
    return true;
    };

/**
 * item.getFontStyle returns the current font style
 *
 * @return font style
 */
DRAWLIB.m_getFontStyleText = function() { return this.p_fontStyle; };

/**
 * item.setFontStyle sets the style to be used for text for text based items.
 * The fontStyle should be an HTML color.
 *
 * @param fontStyle The style for the text
 */
DRAWLIB.m_setFontStyleText = function(fontStyle) {
    this.p_fontStyle = fontStyle;
    };

/**
 * item.getFontFamily returns the font family.
 *
 * @return Font family
 */
DRAWLIB.m_getFontFamilyText = function() { return this.p_fontFamily; };

/**
 * item.setFontFamily sets the font family for text based items.
 *
 * @param fontFamily The font family for the text.
 */
DRAWLIB.m_setFontFamilyText = function(fontFamily) {
    this.p_fontFamily = fontFamily;
    };

/**
 * item.getFontSize returns the text size
 *
 * @return Text size in window units
 */
DRAWLIB.m_getFontSizeText = function() { return this.p_fontSize; };

/**
 * item.setFontSize sets the vertical text size for text based items.
 *
 * @param fontSize Text size in window units.
 */
DRAWLIB.m_setFontSizeText = function(fontSize) {
    this.p_fontSize = Math.round(fontSize);
    this.setBoxes();
    };

/**
 * item.getFontColorStyle returns the text color.
 *
 * @return color style for the text
 */
DRAWLIB.m_getFontColorStyle = function() { return this.p_fontFillStyle; };

/**
 * item.setFontColorStyle sets the color style to be used for text for text
 * based items.
 * The fontStyle should be an HTML color.
 *
 * @param fontColorStyle The style for the text
 */
DRAWLIB.m_setFontColorStyle = function(fontColorStyle) {
    this.p_fontFillStyle = fontColorStyle;
    };
// This shouldn't be used yet as the bounding boxes assume middle center
DRAWLIB.m_setTextAlign = function(textAlign) { this.p_textAlign = textAlign; };
/**
 * item.setTextBaseline sets the text vertical alignment.
 * This library only supports 'top', middle' or 'bottom'
 */
DRAWLIB.m_setTextBaseline = function(textBaseline) {
    this.p_textBaseline = textBaseline;
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

DRAWLIB.p_IMGLIST = {}; // List of images to track when they are loaded

// Extracts the last part of a path, after the last /
DRAWLIB.p_pathEnd = function(aString) {
    var slashIndex = aString.lastIndexOf('/');
    if (slashIndex >= 0) { return aString.slice(slashIndex+1); }
    return aString; // No slash so return the whole string
    };

/**
 * pic.createImage creates an image based drawing item and adds it to the
 * drawing item list.
 * The image is created on layer 0.
 *
 * @param id Item identifier
 * @param p_imgName The URL of the image to use
 * @param x X co-ordinate of the centre point
 * @param y Y co-ordinate of the centre point
 * @param winWidth Width of the rectangle in window units
 * @param winHeight Height of the rectangle in window units
 * @param angle the rotation clockwise in degrees
 * @return the created item
 */
DRAWLIB.m_createImage = function(id, imgName, x, y, winWidth, winHeight, angle) {
    // Derive from Rectangle
    var oneImg = this.createRect(id, x, y, winWidth, winHeight, angle);
    oneImg.p_type = 'I';
    oneImg.getStr = DRAWLIB.m_getStrImg;
    oneImg.p_fillStyle = '#000000'; // Not really but allows pick
    oneImg.p_imgName = imgName;
    var imgFileName = DRAWLIB.p_pathEnd(imgName);
    if (!DRAWLIB.p_IMGLIST[imgFileName]) { // Track unloaded images
        DRAWLIB.p_IMGLIST[imgFileName] = {"loaded":false};
        } 
    oneImg.p_Image = new Image();
    oneImg.p_Image.onload = DRAWLIB.p_onImageLoad;
    oneImg.p_Image.src = imgName;
    oneImg.doDrawImageWithOffset = DRAWLIB.m_doDrawImageWithOffset;
    oneImg.p_draw = DRAWLIB.p_drawImageItem;
    oneImg.drawOffset = DRAWLIB.m_drawOffsetImage;
    oneImg.setBoxes();
    return oneImg;
    };

DRAWLIB.m_getStrImg = function() { // Return JSON version of the object
    var itemStr = '{"t":"I","mx":'+this.p_midX+',"my":'+this.p_midY+
         ',"w":'+this.p_winWidth+',"h":'+this.p_winHeight+',"a":'+this.p_angle+
         ',"img":"'+this.p_imgName+'"';
    if (this.p_layer !== 0) { itemStr += ',"layer":'+this.p_layer; }
    if (this.p_z !== 0) { itemStr += ',"z":'+this.p_z; }
    //var connectors = this.getConnectors();
    //if (connectors) {
    //    itemStr += ',"connect":[';
    //    for (var i = 0 ; i < connectors.length ; i++ ) {
    //        itemStr += connectors[i]+',';
    //        }
    //    itemStr += ']';
    //    }
    itemStr += '}';
    return itemStr;
    };

DRAWLIB.p_onImageLoad = function() { // Must not try to draw until loaded
    var imgFileName = DRAWLIB.p_pathEnd(this.src);
    var thisImg = DRAWLIB.p_IMGLIST[imgFileName];
    if ( thisImg.loaded ) { return; } // Was already loaded
    thisImg.loaded = true; // Can safely draw from now on
    // Check for having loaded all images
    var somePending = false;
    for (var name in DRAWLIB.p_IMGLIST) {
        if (!DRAWLIB.p_IMGLIST[name].loaded) { 
            somePending = true;
            break;
            }
        }
    if (!somePending) {
        DRAWLIB.p_IMGINFO.redrawObj.redrawAll();
         }
    };

// Draw an image with an optional offset in canvas co-ords
DRAWLIB.m_doDrawImageWithOffset = function(ctxt, canvasWidth, window, 
    xOff, yOff) {
    // Don't draw if the image has not yet loaded
    var imgFileName = DRAWLIB.p_pathEnd(this.p_Image.src);
    if (!DRAWLIB.p_IMGLIST[imgFileName].loaded) {
        return;
        }
    this.p_pendingDraw = false;
    // If drawing on main window then check for our of view
    if (ctxt === this.p_pic.p_ctxt &&
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }
    var scale = this.p_pic.p_windowToCanvasContextScale(canvasWidth, window);
    var cMid = this.p_pic.p_windowToCanvasContextCoords(this.p_midX, this.p_midY,
                                                     canvasWidth, window);
    var winRot = this.p_pic.p_rotation;
    cMid[0] += xOff;
    cMid[1] += yOff;
    var canWidth = this.p_winWidth * scale;
    var canHeight = this.p_winHeight * scale;
    ctxt.save();
    ctxt.translate(cMid[0], cMid[1]);
    ctxt.rotate(this.p_radAngle-Math.PI*winRot*0.5);
    ctxt.translate(-cMid[0], -cMid[1]);
    ctxt.drawImage(this.p_Image, cMid[0]-canWidth/2, cMid[1]-canHeight/2,
                   canWidth, canHeight ); 
    ctxt.restore(); 
    };

DRAWLIB.p_drawImageItem = function(ctxt, canvasWidth, window) {
    this.doDrawImageWithOffset(ctxt, canvasWidth, window, 0, 0);
    };

// Offsets in canvas co-ords
DRAWLIB.m_drawOffsetImage = function(oldXOff, oldYOff, xOff, yOff, blank) {
    if (blank) { this.p_redrawOffset(oldXOff, oldYOff); } 
    this.doDrawImageWithOffset(this.p_pic.p_ctxt, this.p_pic.p_canvasWidth,
        this.p_pic.p_window, xOff, yOff);
    this.p_pic.p_redrawOneFrame();
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.


/**
 * pic.createPolyline creates a multi line segment drawing item and adds it
 * to the drawing item list. The line is created with default styles and on
 * layer 0.
 *
 * @param id Item identifier
 * @param points Array of 2-element points
 * @return the created item
 */
DRAWLIB.m_createPolyline = function(id, points) {
    var oneItem = {'p_pic':this, 'p_id':id, 'p_points':[], 'p_dbId':0, 
        'p_drawable':true, 'p_pickable':true, 'p_visible':true, 'p_layer':0,
        'p_neverPickable':false, 'p_type':'P', 'p_subType':'PL',
        'p_arrow1':0, 'p_arrow2':0};
    // Ensure that points are integers
    for (var i = 0 ; i < points.length ; i++) {
        oneItem.p_points.push([Math.round(points[i][0]),
                               Math.round(points[i][1])]);
        }
    oneItem.p_strokeStyle = '#000000';
    oneItem.p_lineWidth = 1;
    oneItem.p_fillStyle = '';
    oneItem.p_z = 0;
    oneItem.p_group = 0;
    oneItem.p_dragging = false;
    oneItem.getId = DRAWLIB.m_getId;
    oneItem.getDbId = DRAWLIB.m_getDbId;
    oneItem.setDbId = DRAWLIB.m_setDbId;
    oneItem.getDrag = DRAWLIB.m_getDrag;
    oneItem.setDrag = DRAWLIB.m_setDrag;
    oneItem.setBoxes = DRAWLIB.m_setBoxesPoly;
    oneItem.getBB = DRAWLIB.m_getBB;
    oneItem.p_draw = DRAWLIB.p_drawPolyline;
    oneItem.highlight = DRAWLIB.m_highlightRect;
    oneItem.drawHandles = DRAWLIB.m_drawHandlesNoRotation;
    oneItem.drawOffset = DRAWLIB.m_drawOffsetPoly;
    oneItem.drawStretch = DRAWLIB.m_drawStretchPoly;
    oneItem.p_blankStretch = DRAWLIB.p_blankStretchRegion;
    oneItem.stretch = DRAWLIB.m_applyStretchToPoly;
    oneItem.getRadAngle = DRAWLIB.m_getAnglePoly;
    oneItem.getAngle = DRAWLIB.m_getAnglePoly;
    oneItem.setAngle = DRAWLIB.m_setAnglePoly;
    oneItem.getLineStyle = DRAWLIB.m_getLineStyle;
    oneItem.setLineStyle = DRAWLIB.m_setLineStyle;
    oneItem.getFillStyle = DRAWLIB.m_getFillStyle;
    oneItem.setFillStyle = DRAWLIB.m_setFillStyle;
    oneItem.getLineWidth = DRAWLIB.m_getLineWidth; 
    oneItem.setLineWidth = DRAWLIB.m_setLineWidth; 
    oneItem.getZ = DRAWLIB.m_getZ; 
    oneItem.setZ = DRAWLIB.m_setZ; 
    oneItem.getLayer = DRAWLIB.m_getLayer; 
    oneItem.setLayer = DRAWLIB.m_setLayer; 
    oneItem.offset = DRAWLIB.m_offsetPoly;
    oneItem.setNeverPickable = DRAWLIB.m_setNeverPickable;
    oneItem.setPickable = DRAWLIB.m_setPickable;
    oneItem.blankOffset = DRAWLIB.m_blankOffset;
    oneItem.p_redrawOffset = DRAWLIB.p_redrawOffset;
    oneItem.pick = DRAWLIB.m_pickPoly;
    oneItem.getStr = DRAWLIB.m_getStrPoly;
    oneItem.getType = DRAWLIB.m_getType;
    oneItem.getSubType = DRAWLIB.m_getSubType;
    //oneItem.getConnectors = getConnectorsRect;
    //oneItem.setConnectors = setConnectorsRect;
    //oneItem.addConnector = addConnectorRect;
    //oneItem.deleteConnector = deleteConnectorRect;
    oneItem.setArrows = DRAWLIB.m_setArrows;
    oneItem.getArrows = DRAWLIB.m_getArrows;
    oneItem.getGroup = DRAWLIB.m_getGroupRect;
    oneItem.setGroup = DRAWLIB.m_setGroupRect;
    this.p_setItem(oneItem);
    oneItem.setBoxes();
    return oneItem;
    };

DRAWLIB.m_getStrPoly = function() { // Return JSON version of the object
    var points = this.p_points;
    var strArr = [];
    strArr.push('{"t":"'+this.p_subType+'","p":["'+points[0][0]+'_'+points[0][1]+'"');
    for (var i = 1 ; i < points.length ; i++) {
        strArr.push(',"'+points[i][0]+'_'+points[i][1]+'"');
        }
    strArr.push('],"lw":'+this.p_lineWidth+',"ls":"'+this.p_strokeStyle+'"');
    if (this.p_layer !== 0) { strArr.push(',"layer":'+this.p_layer); }
    if (this.p_z !== 0) { strArr.push(',"z":'+this.p_z) ; }
    if (this.p_fillStyle) { strArr.push(',"fs":"'+this.p_fillStyle+'"'); }
    if (this.p_arrow1) { strArr.push(',"arrow1":'+this.p_arrow1) ; }
    if (this.p_arrow2) { strArr.push(',"arrow2":'+this.p_arrow2) ; }
    //var connectors = this.getConnectors();
    //if (connectors) {
    //    var itemStr = ',"connect":[';
    //    for (var i = 0 ; i < connectors.length ; i++ ) {
    //        itemStr += connectors[i]+',';
    //        }
    //    itemStr += ']';
    //    strArr.push(itemStr);
    //    }
    strArr.push('}');
    return strArr.join('');
    };

/**
 * item.getSubType returns the sub-type. This is only defined for items
 * derived from polylines. The current values are 'PL' for polyline,
 * 'F' for freehand and 'PG' for polygon.
 *
 * @return item sub type
 */
DRAWLIB.m_getSubType = function() { return this.p_subType; };

// Set drawing boundary and picking bounding box in real world co-ords
DRAWLIB.m_setBoxesPoly = function() {
    var points = this.p_points;
    var minX = points[0][0];
    var minY = points[0][1];
    var maxX = points[0][0];
    var maxY = points[0][1];
    for (var i = 1 ; i < points.length ; i++ ) {
        if (points[i][0] < minX) { minX = points[i][0]; }
        if (points[i][1] < minY) { minY = points[i][1]; }
        if (points[i][0] > maxX) { maxX = points[i][0]; }
        if (points[i][1] > maxY) { maxY = points[i][1]; }
      }
    this.p_pickBB = [minX, minY, maxX, maxY] ;
    this.p_border = [];
    this.p_border[0] = [minX, minY];
    this.p_border[1] = [maxX, minY];
    this.p_border[2] = [maxX, maxY];
    this.p_border[3] = [minX, maxY];
    this.p_border[4] = [minX, minY];
    };

// Don't allow rotation of polylines
DRAWLIB.m_getAnglePoly = function() { return 0; };
DRAWLIB.m_setAnglePoly = function(angle) { };

// Can be used to draw to other contexts than the default
DRAWLIB.p_drawPolyline = function(ctxt, canvasWidth, window) {
    // if main window then check for outside
    if (ctxt === this.p_pic.p_ctxt &&
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }
    var cP = this.p_pic.p_windowToCanvasContextArray(this.p_points,
                                                  canvasWidth, window);
    var len = this.p_points.length;
    var scale = this.p_pic.p_windowToCanvasContextScale(canvasWidth, window);
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = Math.round(scale * this.p_lineWidth);
    ctxt.beginPath();
    ctxt.moveTo(cP[0][0], cP[0][1]);
    for (var i = 1 ; i < len ; i++ ) {
        ctxt.lineTo(cP[i][0], cP[i][1]);
       }
    // If the line has arrows then draw those.
    // arrow1 is at the start and arrow2 is at the end.
    if (this.p_arrow1) {
        var ad1 = this.p_arrow1;
        // Calculate a point back along the line
        var ang1 = Math.atan2( cP[1][1]-cP[0][1], cP[1][0]-cP[0][0] );
        var aP1 = [cP[0][0]+ad1*Math.cos(ang1), cP[0][1]+ad1*Math.sin(ang1)];
        ctxt.moveTo(cP[0][0], cP[0][1]);
        ctxt.lineTo(aP1[0] - 0.5*ad1*Math.sin(ang1),
                    aP1[1] + 0.5*ad1*Math.cos(ang1));
        ctxt.lineTo(aP1[0] + 0.5*ad1*Math.sin(ang1),
                    aP1[1] - 0.5*ad1*Math.cos(ang1));
        ctxt.lineTo(cP[0][0], cP[0][1]);
    }
    if (this.p_arrow2) {
        var ad2 = this.p_arrow2;
        // Calculate a point back along the line
        var pL = cP.length - 1;
        var ang2 = Math.atan2( cP[pL-1][1]-cP[pL][1], cP[pL-1][0]-cP[pL][0] );
        var aP2 = [cP[pL][0]+ad2*Math.cos(ang2), cP[pL][1]+ad2*Math.sin(ang2)];
        ctxt.moveTo(cP[pL][0], cP[pL][1]);
        ctxt.lineTo(aP2[0] - 0.5*ad2*Math.sin(ang2),
                    aP2[1] + 0.5*ad2*Math.cos(ang2));
        ctxt.lineTo(aP2[0] + 0.5*ad2*Math.sin(ang2),
                    aP2[1] - 0.5*ad2*Math.cos(ang2));
        ctxt.lineTo(cP[pL][0], cP[pL][1]);
    }
    ctxt.stroke();
    ctxt.closePath();
    };

// Offsets in canvas co-ords
DRAWLIB.m_drawOffsetPoly = function(oldXOff, oldYOff, xOff, yOff, blank) {
    var cP = this.p_pic.windowToCanvasArray(this.p_points);
    var ctxt = this.p_pic.p_ctxt;
    var scale = this.p_pic.windowToCanvasScale();
    var lw = Math.round(scale * this.p_lineWidth);
    if (blank) { this.p_redrawOffset(oldXOff, oldYOff); }
    // Draw a new line
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.moveTo(xOff+cP[0][0], yOff+cP[0][1]);
    for (var i = 1 ; i < cP.length ; i++ ) {
        ctxt.lineTo(xOff+cP[i][0], yOff+cP[i][1]);
       }
    ctxt.stroke();
    ctxt.closePath();
    // Refresh the frame
    this.p_pic.p_redrawOneFrame();
    };

DRAWLIB.m_offsetPoly = function(xOffset, yOffset) {
    var points = this.p_points;
    // Ensure integral co-ords
    xOffset = Math.round(xOffset);
    yOffset = Math.round(yOffset);
    for (var i = 0 ; i < points.length ; i++ ) {
        points[i][0] += xOffset;
        points[i][1] += yOffset;
        }
    this.setBoxes();
    };

// Is the point x,y in real world co-ords a hit on the line?
DRAWLIB.m_pickPoly = function(x, y) { 
    if (this.p_neverPickable) { return false; }
    var BB = this.p_pickBB;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    var points = this.p_points;
    for (var i = 1 ; i < points.length ; i++){
        if (DRAWLIB.p_isPointNearLine(points[i-1][0], points[i-1][1],
                                      points[i][0], points[i][1],
                                      x, y)) { return true; }
        }
    return false;
    };

// Draw a polyline that is stretched in some way
// The handle is an identifier for the handle that is being dragged.
// 0 to 3 are corner handles, 4 to 7 are mid side handles
DRAWLIB.m_drawStretchPoly = function( handle, oldXOff, oldYOff,
                                      xOff, yOff, blank) {
    if (blank) { this.p_blankStretch( handle, oldXOff, oldYOff); }
    var canLine = this.p_pic.windowToCanvasArray(this.p_points);
    var BB = this.p_pickBB;
    var cBB = this.p_pic.windowToCanvasRect( BB[0], BB[1],
                                               BB[2], BB[3]);
    var sPoints = DRAWLIB.p_stretchPoints(handle, xOff, yOff, canLine,
        [cBB[0], cBB[1]], [cBB[2], cBB[3]]);
    // Draw a new line
    var ctxt = this.p_pic.p_ctxt;
    var lw = 1; // thicker linewidths leave trails
    ctxt.strokeStyle = this.p_strokeStyle;
    ctxt.lineWidth = lw;
    ctxt.beginPath();
    ctxt.moveTo(sPoints[0][0], sPoints[0][1]);
    for (var i = 1 ; i < sPoints.length ; i++) {
        ctxt.lineTo(sPoints[i][0], sPoints[i][1]);
        }
    ctxt.stroke();
    ctxt.closePath();
    };

// Apply a window offset stretch to a polyline based on
// dragging a specific handle
// The offsets ate in canvas co-ords
DRAWLIB.m_applyStretchToPoly = function(handle, xOff, yOff) {
    // Set up diagonal corners and stretch them.
    var BB = this.p_pickBB;
    var sPoints = DRAWLIB.p_stretchPoints(handle, xOff, yOff, this.p_points,
        [BB[0], BB[1]], [BB[2], BB[3]]);
    this.p_points = sPoints;
    this.setBoxes();
    };

/**
 * item.setArrows sets the length of arrow heads for a line.
 *
 * @param arrow1 - length of arrow head at start of line
 * @param arrow2 - length of arrow head at end of line
 */
DRAWLIB.m_setArrows = function( arrow1, arrow2 ) {
    this.p_arrow1 = arrow1;
    this.p_arrow2 = arrow2;
    };

/**
 * item.getArrows returns a 2-element array with the sizes of arrow heads
 */
DRAWLIB.m_getArrows = function() { return [this.p_arrow1, this.p_arrow2]; };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.createFreehand creates a multi line segment drawing item based on a
 * freehand line with short line segments and adds it
 * to the drawing item list. The line is created with default styles and on
 * layer 0.
 *
 * @param id Item identifier
 * @param points Array of 2-element points
 * @return the created item
 */
DRAWLIB.m_createFreehand = function(id, points) {
    // Derive from Polyline
    DRAWLIB.p_optimiseFreehand(points);
    var oneItem = this.createPolyline(id, points);
    oneItem.p_subType = 'F'; // Differentiate between Polyline & freehand
    oneItem.pick = DRAWLIB.m_pickFreehand;
    oneItem.setBoxes();
    return oneItem;
    };

// Is the point x,y in real world co-ords a hit on the image?
DRAWLIB.m_pickFreehand = function(x, y) {
    var BB = this.p_pickBB;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    // Check against vertices - assume short lines
    var points = this.p_points;
    for (var i = 1 ; i < points.length ; i++){
        if ((Math.abs(x-points[i][0]) < marg) &&
            (Math.abs(y-points[i][1]) < marg)) {
            return true;
            }
        }
    return false;
    };

DRAWLIB.p_optimiseFreehand = function(aPoints) {
    // Function to remove redundant points from a polyline.
    // Remove points that are the same.
    // Because we do not want to alter the array while we are working on it,
    // we simply mark points for deletion in the first pass and then delete them
    var len = aPoints.length;
    var deletePoints = []; // Array of indices of points to be deleted
    var i ;
    // First pass - find unnecessary points based on adjacency
    for ( i = 1 ; i < len ; i++ ) {
        var ap1 = aPoints[i-1];
        var ap2 = aPoints[i];
        if ((Math.abs(ap1[0]-ap2[0]) < 1) && (Math.abs(ap1[1]-ap2[1]) < 1)) {
            deletePoints.push(i);
            }
        }   
    // Second pass - delete unnecessary points
    // Do this from the end towards the beginning or the indices become wrong
    var onePoint = deletePoints.pop();
    while (onePoint) {
        aPoints.splice(onePoint, 1);
        onePoint = deletePoints.pop();
        }

    // Find points that are at the same angle between surrounding points and
    // so can be removed without affecting the appearance of a line.
    // Note - cannot remove end points.
    // Because we do not want to alter the array while we are working on it,
    // we simply mark points for deletion in the first pass and then delete them
    // in a second pass.
    // To avoid overly severe effects, we will not remove two adjacent points
    // for now.
    len = aPoints.length;
    deletePoints = []; // Array of indices of points to be deleted
    i = 1 ; // Don't use for loop as we can skip points
    var margin = Math.PI / 36 ; // Approx 5 degrees margin for similar lines
    // First pass - find unnecessary points based on angle
    while (i < len-1) {
        var p1 = aPoints[i-1];
        var p2 = aPoints[i];
        var p3 = aPoints[i+1];
        var ang12 = Math.atan2(p2[1]-p1[1], p2[0]-p1[0]);
        var ang23 = Math.atan2(p3[1]-p2[1], p3[0]-p2[0]);
        // We may miss some with angles being around +/- Pi but don't care
        if (Math.abs(ang23-ang12) < margin) {
            deletePoints.push(i);
            i += 2 ; // Don't try to delete two points in a  row
            }
        else { i += 1; }
        }
    // Second pass - delete unnecessary points
    // Do this from the end towards the beginning or the indices become wrong
    onePoint = deletePoints.pop();
    while (onePoint) {
        aPoints.splice(onePoint, 1);
        onePoint = deletePoints.pop();
        }
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.createPolygon creates a polygon drawing item and adds it
 * to the drawing item list. The polygon is created with default styles and on
 * layer 0.
 *
 * @param id Item identifier
 * @param points Array of 2-element points
 * @param fillStyle The style to fill the polygon - should be an HTML color
 * @return the created item
 */
DRAWLIB.m_createPolygon = function(id, points, fillStyle) {
    // Derive from Polyline
    var oneItem = this.createPolyline(id, points);
    oneItem.p_subType = 'PG';
    oneItem.p_fillStyle = fillStyle;
    oneItem.p_draw =DRAWLIB.p_drawPolygon;
    oneItem.pick = DRAWLIB.m_pickPolygon;
    oneItem.setBoxes();
    return oneItem;
    };

// Is the point x,y in real world co-ords a hit on the image?
DRAWLIB.m_pickPolygon = function(x, y) {
    if (this.p_neverPickable) { return false; }
    var BB = this.p_pickBB;
    var pp = this.p_points;
    var len = pp.length;
    var marg = 5 ; // Margin of error, would be nice to scale
    // Check against crude bounding box
    if (x < BB[0]-marg || x > BB[2]+marg) { return false; }
    if (y < BB[1]-marg || y > BB[3]+marg) { return false; }
    var bord = this.p_border;
    var side1 = DRAWLIB.p_pointSideOfLine(pp[0][0], pp[0][1],
                                          pp[1][0], pp[1][1], x, y);
    for (var i = 1 ; i < len-1 ; i++){
        var side2 = DRAWLIB.p_pointSideOfLine(pp[i][0], pp[i][1],
                                              pp[i+1][0], pp[i+1][1], x, y);
        if (((side1 < 0) && (side2 > 0)) || ((side1 > 0) && (side2 < 0))) {
            return false;
            }
        if (side1 === 0) { side1 = side2; }
       }
    return true;
    };

// Can be used to draw to other contexts than the default
DRAWLIB.p_drawPolygon = function(ctxt, canvasWidth, window) {
    // If in main window, check for outside
    if (ctxt === this.p_pic.p_ctxt &&
        !DRAWLIB.p_isInWindow(this.p_pickBB, window)) { return; }
    var cP = this.p_pic.p_windowToCanvasContextArray(this.p_points,
                                                  canvasWidth, window);
    var len = this.p_points.length;
    ctxt.fillStyle = this.p_fillStyle;
    ctxt.beginPath();
    ctxt.moveTo(cP[0][0], cP[0][1]);
    for (var i = 1 ; i < len ; i++ ) {
        ctxt.lineTo(cP[i][0], cP[i][1]);
       }
    ctxt.closePath();
    ctxt.fill();
    };

//Copyright (c) 2009-2011, Ian McDowall
//All rights reserved.
//
//Redistribution and use in source and binary forms, with or without 
//modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * pic.addBackground adds an image for use as background
 * The image is not considered to exist on any layer, it lies behind them all
 *
 * @param p_imgName The URL of the image to use
 * @param width Width of the image in pixels
 * @param height Height of the image in pixels
 * @return the created item
 */
DRAWLIB.m_addBackground = function(imgName, width, height) {
    // Derive from Rectangle
    var oneImg = {'p_imgName':imgName, 'p_width':width, 'p_height':height};
    oneImg.getStr = DRAWLIB.m_getStrBack;
    var imgFileName = DRAWLIB.p_pathEnd(imgName);
    if (!DRAWLIB.p_IMGLIST[imgFileName]) { // Track unloaded images
        DRAWLIB.p_IMGLIST[imgFileName] = {"loaded":false};
        } 
    oneImg.p_Image = new Image();
    oneImg.p_Image.onload = DRAWLIB.p_onImageLoad;
    oneImg.p_Image.src = imgName;
    oneImg.draw = DRAWLIB.m_doDrawBack;
    oneImg.drawBackgroundCanvasSect = DRAWLIB.m_doDrawBackgroundCanvasSect;
    oneImg.p_pic = this;
    this.p_backgroundImage = oneImg;
    };

DRAWLIB.p_mkImgPart = function(imgName) {
    var imgFileName = DRAWLIB.p_pathEnd(imgName);
    if (!DRAWLIB.p_IMGLIST[imgFileName]) {
	DRAWLIB.p_IMGLIST[imgFileName] = {"loaded":false};
	} 
    var img = new Image();
    img.onload = DRAWLIB.p_onImageLoad;
    img.src = imgName;
    return img;
}

/**
 * pic.addBackground4 adds a set of images for use as background
 * The image is not considered to exist on any layer, it lies behind them all
 *
 * @param id Item identifier
 * @param width Width of the image in pixels
 * @param height Height of the image in pixels
 * @param p_imgName0 The URL of the image to use in 0 rotation
 * @param p_imgName1 The URL of the image to use in 1 rotation
 * @param p_imgName2 The URL of the image to use in 2 rotation
 * @param p_imgName3 The URL of the image to use in 3 rotation
 * @return the created item
 */
DRAWLIB.m_addBackground4 = function(width, height, imgName0, imgName1, imgName2, imgName3) {
    var oneImg = {'p_imgName':imgName0, 'p_width':width, 'p_height':height};
    oneImg.p_ImageSet = [
        DRAWLIB.p_mkImgPart(imgName0),
        DRAWLIB.p_mkImgPart(imgName1),
        DRAWLIB.p_mkImgPart(imgName2),
        DRAWLIB.p_mkImgPart(imgName3)];
    oneImg.draw = DRAWLIB.m_doDrawBack4;
    oneImg.drawBackgroundCanvasSect = DRAWLIB.m_doDrawBackgroundCanvasSect;
    oneImg.p_pic = this;
    this.p_backgroundImage4 = oneImg;
    };

//TODO extend for back4
DRAWLIB.m_getStrBack = function() { // Return JSON version of the object
    var itemStr = '{"t":"BK","wid":'+this.p_width+',"ht":'+this.p_height+
         ',"img":"'+this.p_imgName+'"}';
    return itemStr;
    };

// Draw a background image to fill the canvas, zoomed appropriately
// TODO allow picture rotation
DRAWLIB.m_doDrawBack = function(ctxt, canvasWidth, canvasHeight, window) {
    // Don't draw if the image has not yet loaded
    var imgFileName = DRAWLIB.p_pathEnd(this.p_Image.src);
    if (!DRAWLIB.p_IMGLIST[imgFileName].loaded) {
        alert("returning because not yet loaded");
        return;
        }
    this.p_pendingDraw = false;

    var pic = this.p_pic;
    var winRot = pic.p_rotation;
    ctxt.save();
    ctxt.translate(canvasWidth/2, canvasHeight/2);
    ctxt.rotate(-Math.PI*winRot*0.5);
    ctxt.translate(-canvasWidth/2, -canvasHeight/2);

    var wb = pic.p_windowBoundary;
    var iwScale = this.p_width / wb[2] ;
    // Work out the image section based on rotation
    var icSect = [0, 0];
    if (winRot == 0 || winRot == 2) {
        var iTL = [ iwScale * window[0], iwScale * window[1] ];
        // icScale is the number of image pixels per canvas pixel
        var icScale =  (canvasWidth / this.p_width) * (wb[2]) / (window[2]) ;
        iSect = [ canvasWidth/icScale, canvasHeight/icScale];
        //alert("Window boundary "+wb[0]+","+wb[1]+" "+wb[2]+","+wb[3]+
        //    " Supplied window "+window[0]+","+window[1]+" "+window[2]+","+window[3]+
        //    " canvas "+canvasWidth+","+canvasHeight+
        //    " image size="+this.p_width+","+this.p_height+" icScale="+icScale+
        //    " Image section "+iTL[0]+","+iTL[1]+" "+iSect[0]+","+iSect[1])
        ctxt.drawImage(this.p_Image, 
            iTL[0], iTL[1], iSect[0], iSect[1],
            0, 0, canvasWidth, canvasHeight);
        } else {
        var iTL = [ iwScale * window[1], iwScale * window[0] ];
        // icScale is the number of image pixels per canvas pixel
        var icScale =  (canvasWidth / this.p_height) * (wb[2]) / (window[2]) ;
        iSect = [ canvasHeight/icScale, canvasWidth/icScale];
        //alert("Window boundary "+wb[0]+","+wb[1]+" "+wb[2]+","+wb[3]+
        //    " Supplied window "+window[0]+","+window[1]+" "+window[2]+","+window[3]+
        //    " canvas "+canvasWidth+","+canvasHeight+
        //    " image size="+this.p_width+","+this.p_height+" icScale="+icScale+
        //    " Image section "+iTL[0]+","+iTL[1]+" "+iSect[0]+","+iSect[1])
        //ctxt.drawImage(this.p_Image, 
        //    iTL[0], iTL[1], iSect[0], iSect[1],
        //    0, 0, canvasHeight, canvasWidth);
        ctxt.drawImage(this.p_Image, 
            //0, 0, this.p_width, this.p_height,
            -canvasHeight/2, -canvasWidth/2, canvasHeight, canvasWidth);
        }
    ctxt.restore(); 
    };

// Draw a background image to fill the canvas, zoomed appropriately
DRAWLIB.m_doDrawBack4 = function(ctxt, canvasWidth, canvasHeight, window) {
    var pic = this.p_pic;
    var winRot = pic.p_rotation;
    var wb = pic.p_windowBoundary;
    // Don't draw if the image has not yet loaded
    var imgFileName = DRAWLIB.p_pathEnd(this.p_ImageSet[winRot].src);
    if (!DRAWLIB.p_IMGLIST[imgFileName].loaded) {
        alert("returning because not yet loaded");
        return;
        }
    this.p_pendingDraw = false;

    // Work out the image section based on rotation
    // ori is the location of the top left point but allowing for rotation
    var ori = [0, 0]
    // iTL is the origin of the displayed section of the image in image pixels
    var iTL = [0, 0];
    // iSect is the dimensions of the displayed section of the image in image pixels
    var iSect = [0, 0];
    if (winRot == 0 || winRot == 2) {
        if (winRot == 0) {
        ori = [window[0], window[1]];
        } else { // 180 degrees
        ori = [wb[2] - (window[0] + window[2]),
               wb[3] - (window[1] + window[3])]
        }
        iTL = [ Math.floor((ori[0] / wb[2]) * this.p_width), 
                Math.floor((ori[1] / wb[2]) * this.p_width)];
        // icScale is the number of image pixels per canvas pixel
        var icScale = (this.p_width / canvasWidth) / (wb[2] / window[2]);
        iSect = [ Math.floor(canvasWidth * icScale), 
                  Math.floor(canvasHeight * icScale)];
    } else { // Rotation 1 or 3
        if (winRot == 1) { // 90 degrees anti-clockwise
          ori = [ window[1], wb[2] - (window[0] + window[2])];
        } else { // 90 degrees clockwise
          ori = [ wb[3] - (window[1] + window[3]), window[0]];
        }
        iTL = [ Math.floor((ori[0] / wb[3]) * this.p_height), 
                Math.floor((ori[1] / wb[3]) * this.p_height)];
        // icScale is the number of image pixels per canvas pixel
        var icScale = (this.p_width / canvasWidth) / (wb[2] / window[2]);
        iSect = [ Math.floor(canvasWidth * icScale),
                  Math.floor(canvasHeight * icScale)];
    }
    alert("Rotation "+winRot+
        " Window boundary "+wb[0]+","+wb[1]+" "+wb[2]+","+wb[3]+
        " Supplied window "+window[0]+","+window[1]+" "+window[2]+","+window[3]+
        " canvas "+canvasWidth+","+canvasHeight+
        " this width+height "+this.p_width+","+this.p_height+
        " image size="+this.p_width+","+this.p_height+" icScale="+icScale+
        " Image section "+iTL[0]+","+iTL[1]+" "+iSect[0]+","+iSect[1])
    ctxt.drawImage(this.p_ImageSet[winRot], 
        iTL[0], iTL[1], iSect[0], iSect[1],
        0, 0, canvasWidth, canvasHeight);
    };

// Draw a section of the image for a section of the canvas
DRAWLIB.m_doDrawBackgroundCanvasSect = function(cBB) {
    // Don't draw if the image has not yet loaded
    var imgFileName = DRAWLIB.p_pathEnd(this.p_Image.src);
    if (!DRAWLIB.p_IMGLIST[imgFileName].loaded) {
        alert("returning because not yet loaded");
        return;
        }
    this.p_pendingDraw = false;

    var pic = this.p_pic;
    var ctxt = pic.p_canvas.getContext("2d");
    var wb = pic.p_windowBoundary;
    var win = pic.p_window;
    // Work out what proportion of the image will be viewable
    // The scale is based on the full window viewport but only a
    // section will be redrawn
    // We need to calculate the TL of the section in window co-ords
    var wTL = pic.p_canvasToWindowCoords(cBB[0], cBB[1]);
    // And then convert it to image co-ords
    // This assumes that the window origin matches the image origin
    var iwScale = this.p_width / wb[2] ;
    var iTL = [ wTL[0]*iwScale, wTL[1]*iwScale ];
    // icScale is the number of image pixels per canvas pixel
    var icScale =  (pic.p_canvas.width * wb[2]) / (win[2] * this.p_width) ;
    var iSect = [ (cBB[2]+1-cBB[0])/icScale, (cBB[3]+1-cBB[1])/icScale ];
    //
    var dbgstr = "wb[2]="+wb[2]+" win[2]="+win[2]+" img width="+this.p_width+" canvas width="+pic.p_canvas.width+
    " wtl="+wTL[0]+","+wTL[1]+" itl="+iTL[0]+","+iTL[1]+"\n"+
    " Canvas rect "+cBB[0]+","+cBB[1]+","+cBB[2]+","+cBB[3]+
    " icscale="+icScale+" iwScale="+iwScale+"\n"+
    " Image rect "+iTL[0]+","+iTL[1]+" "+iSect[0]+","+iSect[1];
    //alert(dbgstr);
    ctxt.drawImage(this.p_Image, 
        iTL[0], iTL[1], iSect[0], iSect[1],
        cBB[0], cBB[1], cBB[2]+1-cBB[0], cBB[3]+1-cBB[1]);
    };
